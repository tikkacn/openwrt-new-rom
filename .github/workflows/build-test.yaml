name: Build X86_64 OpenWrt (分步式)

on:
  schedule:
    - cron: '0 16 * * *'  # UTC 16:00 = 北京时间 0:00
  push:
    branches:
      - main
    paths:
      - '.config'
      - 'diy-*.sh'
      - '.github/workflows/*.yml'
  pull_request:
    paths:
      - '.config'
      - 'diy-*.sh'
      - '.github/workflows/*.yml'
  workflow_dispatch:
    inputs:
      manual_start_stage:
        description: 'Start from stage (1-4)'
        required: true
        default: '1'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'

# 限制权限
permissions:
  contents: write  # 需要写权限用于创建releases
  packages: read
  deployments: write

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF: feeds.conf.default
  CONFIG_FILE: .config
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_BIN_DIR: false
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: false
  TZ: Asia/Shanghai
  WORKDIR: /mnt/openwrt
  OPENWRT_ROOT: /mnt/openwrt/openwrt
  # 新增环境变量
  RETRY_COUNT: 3
  RETRY_WAIT: 30
  TIMEOUT: 600

jobs:
  check-updates-and-status:
    runs-on: ubuntu-22.04
    outputs:
      has_updates: ${{ steps.check.outputs.has_updates }}
      start_stage: ${{ steps.check-status.outputs.start_stage }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for updates
        id: check
        run: |
          # 手动触发时直接返回 true
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "has_updates=true" >> $GITHUB_OUTPUT
            echo "Manual trigger, will proceed with build"
            exit 0
          fi

          # 自动触发时检查更新
          git clone --depth=1 ${{ env.REPO_URL }} temp_dir
          cd temp_dir
          LATEST_HASH=$(git rev-parse HEAD)
          
          # Use the GitHub API to get the latest successful workflow run's head SHA.
          API_URL="https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow }}/runs?status=completed&conclusion=success&per_page=1"
          LAST_HASH=$(curl -s "$API_URL" | jq -r '.workflow_runs[0].head_sha // ""')
          
          echo "Latest commit hash: $LATEST_HASH"
          echo "Last successful commit hash: $LAST_HASH"

          ./scripts/feeds update -a
          FEEDS_UPDATED=$(git status -s feeds.conf.default package/feeds | wc -l)

          if [ "$LATEST_HASH" != "$LAST_HASH" ] || [ "$FEEDS_UPDATED" -gt 0 ]; then
            echo "has_updates=true" >> $GITHUB_OUTPUT
            echo "Found updates, will proceed with build"
          else
            echo "has_updates=false" >> $GITHUB_OUTPUT
            echo "No updates found, skipping build"
          fi

      - name: Set start stage
        id: check-status
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "start_stage=${{ github.event.inputs.manual_start_stage }}" >> $GITHUB_OUTPUT
          else
            echo "start_stage=1" >> $GITHUB_OUTPUT
          fi

  stage1-prepare:
    needs: check-updates-and-status
    if: needs.check-updates-and-status.outputs.has_updates == 'true' && (needs.check-updates-and-status.outputs.start_stage == '1')
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize environment
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          # 首先清理空间
          echo "=== Before Cleanup ==="
          df -h

          # 删除不需要的大型软件包和目录
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/.ghcup \
                      /usr/local/share/powershell /usr/share/gradle* /usr/share/maven /usr/share/swift

          sudo -E apt-get -qq purge azure-cli ghc* zulu* hhvm llvm* firefox google* dotnet* powershell \
                                     openjdk* adoptopenjdk* mongodb* mysql* php* -y || true
          sudo -E apt-get -qq autoremove --purge -y
          sudo -E apt-get -qq clean

          echo "=== After Cleanup ==="
          df -h

          # 设置时区并安装依赖
          sudo timedatectl set-timezone "$TZ"
          sudo -E apt-get -qq update
          sudo -E apt-get -qq install $(curl -fsSL git.io/depends-ubuntu-2204) -y

          # 准备工作目录
          sudo mkdir -p ${{ env.WORKDIR }}
          sudo chown $USER:$USER ${{ env.WORKDIR }}

      - name: Clone source code
        working-directory: ${{ env.WORKDIR }}
        run: |
          git clone --depth=1 $REPO_URL -b $REPO_BRANCH openwrt
          ln -sf ${{ env.OPENWRT_ROOT }} openwrt
          echo "Source code cloned to ${{ env.OPENWRT_ROOT }}"
          ls -la ${{ env.OPENWRT_ROOT }}

      - name: Cache OpenWrt source code
        uses: actions/cache@v3
        with:
          path: ${{ env.OPENWRT_ROOT }}
          key: openwrt-source-${{ runner.os }}-${{ hashFiles('**/feeds.conf.default') }}
          restore-keys: |
            openwrt-source-${{ runner.os }}-

  stage2-feeds:
    needs: [check-updates-and-status, stage1-prepare]
    if: needs.check-updates-and-status.outputs.has_updates == 'true' && (needs.check-updates-and-status.outputs.start_stage == '1' || needs.check-updates-and-status.outputs.start_stage == '2')
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore stage1 cache
        uses: actions/cache/restore@v3
        with:
          path: ${{ env.OPENWRT_ROOT }}
          key: openwrt-source-${{ runner.os }}-${{ hashFiles('**/feeds.conf.default') }}
          restore-keys: |
            openwrt-source-${{ runner.os }}-
          fail-on-cache-miss: true

      - name: Load custom feeds
        run: |
          if [ -e "$GITHUB_WORKSPACE/$FEEDS_CONF" ]; then
            mv "$GITHUB_WORKSPACE/$FEEDS_CONF" ${{ env.OPENWRT_ROOT }}/feeds.conf.default
          else
            echo "::error::$FEEDS_CONF file not found in repository"
            exit 1
          fi
          cd ${{ env.OPENWRT_ROOT }}
          ./scripts/feeds clean

          # 使用重试机制更新 feeds
          update_feeds_with_retry() {
            for i in $(seq 1 ${{ env.RETRY_COUNT }}); do
              echo "Updating feeds attempt $i of ${{ env.RETRY_COUNT }}"
              if ./scripts/feeds update -a; then
                return 0
              fi
              sleep ${{ env.RETRY_WAIT }}
            done
            return 1
          }

          if ! update_feeds_with_retry; then
            echo "::error::Failed to update feeds after ${{ env.RETRY_COUNT }} attempts"
            exit 1
          fi

          ./scripts/feeds install -a

      - name: Run DIY script part 1
        run: |
          cd ${{ env.OPENWRT_ROOT }}
          if [ -f "$GITHUB_WORKSPACE/$DIY_P1_SH" ]; then
            chmod +x "$GITHUB_WORKSPACE/$DIY_P1_SH"
            if ! "$GITHUB_WORKSPACE/$DIY_P1_SH"; then
              echo "::error::DIY script execution failed"
              exit 1
            fi
          else
            echo "::warning::$DIY_P1_SH file not found, skipping custom script"
          fi

      - name: Cache OpenWrt feeds
        uses: actions/cache@v3
        with:
          path: ${{ env.OPENWRT_ROOT }}
          key: openwrt-feeds-${{ runner.os }}-${{ hashFiles('**/feeds.conf.default') }}-${{ github.sha }}
          restore-keys: |
            openwrt-feeds-${{ runner.os }}-${{ hashFiles('**/feeds.conf.default') }}-
            openwrt-feeds-${{ runner.os }}-

  stage3-compile:
    needs: [check-updates-and-status, stage2-feeds]
    if: needs.check-updates-and-status.outputs.has_updates == 'true' && (needs.check-updates-and-status.outputs.start_stage == '1' || needs.check-updates-and-status.outputs.start_stage == '2' || needs.check-updates-and-status.outputs.start_stage == '3')
    runs-on: ubuntu-22.04
    timeout-minutes: 360  # 设置6小时总超时
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore stage2 cache
        uses: actions/cache/restore@v3
        with:
          path: ${{ env.OPENWRT_ROOT }}
          key: openwrt-feeds-${{ runner.os }}-${{ hashFiles('**/feeds.conf.default') }}-${{ github.sha }}
          restore-keys: |
            openwrt-feeds-${{ runner.os }}-${{ hashFiles('**/feeds.conf.default') }}-
            openwrt-source-${{ runner.os }}-${{ hashFiles('**/feeds.conf.default') }}

      - name: Install additional dependencies
        run: |
          sudo -E apt-get -qq update
          sudo -E apt-get -qq install build-essential clang flex bison g++ gawk gcc-multilib g++-multilib \
          gettext git libncurses5-dev libssl-dev python3-distutils rsync unzip zlib1g-dev \
          file wget python3 python3-pip python3-ply python3-setuptools ninja-build libpcre3-dev -y

          # 确保 ninja 在正确的位置
          sudo mkdir -p ${{ env.OPENWRT_ROOT }}/staging_dir/host/bin
          sudo ln -sf $(which ninja) ${{ env.OPENWRT_ROOT }}/staging_dir/host/bin/ninja
          ls -la ${{ env.OPENWRT_ROOT }}/staging_dir/host/bin/ninja
          ${{ env.OPENWRT_ROOT }}/staging_dir/host/bin/ninja --version

      - name: Load custom configuration
        run: |
          cd ${{ env.OPENWRT_ROOT }}
          echo "CONFIG_PACKAGE_baresip-mod-avcodec=n" > .config.new
          echo "CONFIG_PACKAGE_baresip-mod-avformat=n" >> .config.new

          if [ -e "$GITHUB_WORKSPACE/$CONFIG_FILE" ]; then
            cat "$GITHUB_WORKSPACE/$CONFIG_FILE" >> .config.new
          fi

          mv .config.new .config
          make defconfig

          [ -e files ] && mv files files/

          if [ -f "$GITHUB_WORKSPACE/$DIY_P2_SH" ]; then
            chmod +x "$GITHUB_WORKSPACE/$DIY_P2_SH"
            if ! "$GITHUB_WORKSPACE/$DIY_P2_SH"; then
              echo "::error::DIY script part 2 execution failed"
              exit 1
            fi
          else
            echo "::warning::$DIY_P2_SH file not found, skipping custom script"
          fi

      - name: Download package
        id: package
        run: |
          cd ${{ env.OPENWRT_ROOT }}
          make defconfig

          # 定义下载重试函数
          download_with_retry() {
            local package=$1
            local attempt=1

            while [ $attempt -le ${{ env.RETRY_COUNT }} ]; do
              echo "Downloading $package (Attempt $attempt of ${{ env.RETRY_COUNT }})..."
              if timeout ${{ env.TIMEOUT }} make package/$package/download V=s; then
                return 0
              fi
              echo "Download failed, waiting ${{ env.RETRY_WAIT }} seconds..."
              sleep ${{ env.RETRY_WAIT }}
              attempt=$((attempt + 1))
            done
            return 1
          }

          # 首先尝试并行下载
          if ! timeout 1800 make download -j8; then
            echo "Parallel download failed, switching to sequential download..."

            # 定义问题包列表
            problem_packages=(
              "busybox"
              "e2fsprogs"
              "f2fs-tools"
              "jsonfilter"
              "lua"
              "util-linux"
            )

            # 逐个下载问题包
            for pkg in "${problem_packages[@]}"; do
              if [ ! -f "dl/${pkg}*.tar.*" ]; then
                if ! download_with_retry "$pkg"; then
                  echo "::error::Failed to download $pkg after ${{ env.RETRY_COUNT }} attempts"
                  exit 1
                fi
              fi
            done
          fi

          # 检查下载失败的文件
          failed_files=$(find dl -size -1024c)
          if [ ! -z "$failed_files" ]; then
            echo "::warning::Some files failed to download:"
            echo "$failed_files"
            find dl -size -1024c -exec rm -f {} \;
          fi

      - name: Compile firmware
        id: compile
        run: |
          cd ${{ env.OPENWRT_ROOT }}
          echo "Working directory space:"
          df -h ${{ env.WORKDIR }}

          # 设置临时目录到工作目录
          export TMPDIR=${{ env.WORKDIR }}/tmp
          mkdir -p $TMPDIR

          # 启用 ccache
          export USE_CCACHE=1
          export CCACHE_DIR=${{ env.WORKDIR }}/.ccache
          mkdir -p $CCACHE_DIR

          # 优化编译参数
          export FORCE_UNSAFE_CONFIGURE=1
          MEM_FREE_GB=$(free -g | awk '/^Mem:/{print int($2 * 0.9)}')
          NPROC=$(nproc)
          JOBS=$((MEM_FREE_GB < NPROC ? MEM_FREE_GB : NPROC))
          echo "Using $JOBS compilation threads"

          # 先编译 gn
          make package/feeds/packages/gn/host/compile -j1 V=s || true

          # 主编译过程
          if ! make -j$JOBS; then
            echo "::warning::Parallel build failed, trying with single thread"
            if ! make -j1 V=s; then
              echo "::error::Build failed even with single thread"
              exit 1
            fi
          fi

          echo "status=success" >> $GITHUB_OUTPUT
          grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' > DEVICE_NAME
          [ -s DEVICE_NAME ] && echo "DEVICE_NAME=_$(cat DEVICE_NAME)" >> $GITHUB_ENV
          echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

      - name: Cache firmware
        if: steps.compile.outcome == 'success'
        uses: actions/cache@v3
        with:
          path: |
            ${{ env.OPENWRT_ROOT }}/bin/targets
            !${{ env.OPENWRT_ROOT }}/bin/targets/**/packages
          key: openwrt-firmware-${{ runner.os }}-${{ github.sha }}

  stage4-upload:
    needs: [check-updates-and-status, stage3-compile]
    if: needs.check-updates-and-status.outputs.has_updates == 'true' && (needs.check-updates-and-status.outputs.start_stage == '1' || needs.check-updates-and-status.outputs.start_stage == '2' || needs.check-updates-and-status.outputs.start_stage == '3' || needs.check-updates-and-status.outputs.start_stage == '4')
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore firmware cache
        uses: actions/cache/restore@v3
        with:
          path: |
            ${{ env.OPENWRT_ROOT }}/bin/targets
        key: openwrt-firmware-${{ runner.os }}-${{ github.sha }}
        fail-on-cache-miss: true

      - name: Check firmware existence
        id: check-firmware
        run: |
          if [ -d "${{ env.OPENWRT_ROOT }}/bin/targets" ]; then
            echo "firmware_exists=true" >> $GITHUB_OUTPUT
            echo "Firmware directory found"
          else
            echo "::error::Firmware directory not found"
            exit 1
          fi

      - name: Upload bin directory
        uses: actions/upload-artifact@v3
        if: env.UPLOAD_BIN_DIR == 'true' && steps.check-firmware.outputs.firmware_exists == 'true'
        with:
          name: OpenWrt_bin${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
          path: ${{ env.OPENWRT_ROOT }}/bin
          retention-days: 5

      - name: Organize files
        id: organize
        if: steps.check-firmware.outputs.firmware_exists == 'true'
        run: |
          cd ${{ env.OPENWRT_ROOT }}/bin/targets/*/*
          rm -rf packages
          FIRMWARE=$(pwd)
          echo "FIRMWARE=$FIRMWARE" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Upload firmware directory
        uses: actions/upload-artifact@v3
        if: steps.organize.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true'
        with:
          name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
          path: ${{ env.FIRMWARE }}
          retention-days: 5

      - name: Generate release tag
        id: tag
        if: env.UPLOAD_RELEASE == 'true' && steps.organize.outputs.status == 'success'
        run: |
          RELEASE_TAG=$(date +"%Y.%m.%d-%H%M")
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

          # 创建发布说明
          cat > release.txt <<EOL
## OpenWrt Firmware - Build $(date +"%Y.%m.%d-%H%M")
### Build Information
- Build Date: $(date)
- Build Type: Automated Build
- Target Device: ${{ env.DEVICE_NAME }}
### SHA256 Checksums
$(cd ${{ env.FIRMWARE }} && find . -type f -name "*.bin" -o -name "*.img" | while read file; do echo "- ${file#./}: $(sha256sum "$file" | cut -d' ' -f1)"; done)
### Notes
- This is an automated build, please test before using in production
- Report any issues on the GitHub repository
EOL
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Upload firmware to release
        uses: softprops/action-gh-release@v1
        if: steps.tag.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.release_tag }}
          body_path: release.txt
          files: ${{ env.FIRMWARE }}/*
          draft: false
          prerelease: false

      - name: Delete workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          retain_days: 1
          keep_minimum_runs: 3

      - name: Remove old releases
        uses: dev-drprasad/delete-older-releases@v0.1.0
        if: env.UPLOAD_RELEASE == 'true'
        with:
          keep_latest: 3
          delete_tags: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Delete old artifacts
        uses: actions/github-script@v6
        with:
          script: |
            const days = 5;
            const ms = days * 24 * 60 * 60 * 1000;
            const now = new Date();

            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            for (const artifact of artifacts.data.artifacts) {
              const created = new Date(artifact.created_at);
              if (now - created > ms) {
                console.log(`Deleting artifact: ${artifact.name}`);
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
              }
            }
