# YAMLæ–‡ä»¶é¡¶éƒ¨ï¼Œæ— å‰å¯¼ç©ºæ ¼
name: å…¨æ–°ç¼–è¯‘ç¬¬13ç‰ˆ(Docker-S3FullEnvCache)

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSHè°ƒè¯• (åœ¨Dockerå®¹å™¨å†…éƒ¨)'
        required: false
        default: 'false'
      clean_build:
        description: 'å…¨æ–°ç¼–è¯‘ï¼Œä¸ä½¿ç”¨S3æ¢å¤çš„ç¯å¢ƒã€‚ä»ä¼šæ‰“åŒ…ä¸Šä¼ æ–°ç¯å¢ƒåˆ°S3ã€‚é¦–æ¬¡S3å¡«å……æ—¶åº”ä¸ºfalseå¹¶é¢„æ¸…ç©ºS3ã€‚'
        required: false
        default: 'false'
      config_file:
        description: 'é…ç½®æ–‡ä»¶å (ä½äºä»“åº“æ ¹ç›®å½•)'
        required: false
        default: 'å¢é‡ç¼“å­˜ä¼˜åŒ–.config'

env: # 2 ç©ºæ ¼ç¼©è¿› (ç›¸å¯¹äºä¸Šä¸€çº§ï¼Œä½†è¿™é‡Œæ˜¯é¡¶çº§env)
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE_IN_REPO: ${{ github.event.inputs.config_file || 'å¢é‡ç¼“å­˜ä¼˜åŒ–.config' }}
  DIY_P1_SH_IN_REPO: diy-part1.sh
  DIY_P2_SH_IN_REPO: diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai

  RUNNER_CHECKOUT_SUBDIR: 'repo_files' 
  CONTAINER_REPO_CONFIG_MOUNT: /repo_config 

  DOCKER_IMAGE: ubuntu:22.04
  S3_WORKSPACE_ARCHIVE_FILENAME: openwrt_workspace_cache.tar.zst
  S3_CONFIG_SNAPSHOT_FILENAME: last_successful_build.config

  CONTAINER_CCACHE_LOGFILE_PATH: /tmp/ccache_detailed.log 
  CONTAINER_DEBUG_LOG_FILE_PATH: /tmp/build_debug_summary.log 

  BUILD_STATE_DIR_NAME: .github_actions_build_state
  CCACHE_DIR_NAME: .ccache

jobs: # 2 ç©ºæ ¼ç¼©è¿›
  build_in_docker: # 4 ç©ºæ ¼ç¼©è¿›
    runs-on: ubuntu-22.04 # 6 ç©ºæ ¼ç¼©è¿›
    name: Build OpenWrt in Docker with S3 Env Cache # 6 ç©ºæ ¼ç¼©è¿›
    env: # 6 ç©ºæ ¼ç¼©è¿›
      RUNNER_OPENWRT_WORKSPACE: /workdir/openwrt_s3_env # 8 ç©ºæ ¼ç¼©è¿›
      CONTAINER_BUILD_AREA: /build_area # 8 ç©ºæ ¼ç¼©è¿›
    steps: # 6 ç©ºæ ¼ç¼©è¿›
      - name: æ£€å‡ºä»“åº“ä»£ç  (Checkout Repository Code) # 8 ç©ºæ ¼ç¼©è¿› (æ³¨æ„'-'æœ¬èº«æ˜¯åˆ—è¡¨é¡¹çš„ä¸€éƒ¨åˆ†)
        uses: actions/checkout@v4 # 10 ç©ºæ ¼ç¼©è¿›
        with: # 10 ç©ºæ ¼ç¼©è¿›
          path: ${{ env.RUNNER_CHECKOUT_SUBDIR }} # 12 ç©ºæ ¼ç¼©è¿›

      - name: è®¾ç½® S3 ç¼“å­˜çš„å®Œæ•´è·¯å¾„å‰ç¼€ (Set Full S3 Cache Path Prefix) # 8 ç©ºæ ¼ç¼©è¿›
        id: set_s3_vars # 10 ç©ºæ ¼ç¼©è¿›
        run: | # 10 ç©ºæ ¼ç¼©è¿›, åç»­è„šæœ¬è¡Œä»12ç©ºæ ¼å¼€å§‹
          s3_prefix_from_secret="${{ secrets.S3_CACHE_PATH_PREFIX }}"
          repo_branch_for_path="${{ env.REPO_BRANCH }}"
          repo_branch_for_path_sanitized=$(echo "$repo_branch_for_path" | sed 's/\//-/g')
          
          final_s3_prefix=""
          if [ -n "$s3_prefix_from_secret" ]; then
            final_s3_prefix="$s3_prefix_from_secret"
            echo "ä½¿ç”¨æ¥è‡ª Secret 'S3_CACHE_PATH_PREFIX' çš„S3è·¯å¾„å‰ç¼€: $final_s3_prefix"
          else
            default_prefix="openwrt-s3env-caches/${repo_branch_for_path_sanitized}"
            final_s3_prefix="$default_prefix"
            echo "ä½¿ç”¨é»˜è®¤S3è·¯å¾„å‰ç¼€: $final_s3_prefix"
          fi
          echo "S3_EFFECTIVE_PATH_PREFIX=${final_s3_prefix}" >> $GITHUB_ENV
          echo "s3_prefix_out=${final_s3_prefix}" >> $GITHUB_OUTPUT
          echo "DEBUG_LOG_ON_RUNNER=${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}/build_debug_summary_runner.log" >> $GITHUB_ENV

      - name: ä¼˜åŒ–Runnerç£ç›˜ç©ºé—´ (Maximize Runner Build Space) # 8 ç©ºæ ¼ç¼©è¿›
        uses: easimon/maximize-build-space@master # 10 ç©ºæ ¼ç¼©è¿›
        with: # 10 ç©ºæ ¼ç¼©è¿›
          root-reserve-mb: 10240 # 12 ç©ºæ ¼ç¼©è¿›
          swap-size-mb: 2048
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'false'
          build-mount-path: '/workdir'

      - name: é…ç½® AWS å‡­è¯ (Configure AWS Credentials) # 8 ç©ºæ ¼ç¼©è¿›
        uses: aws-actions/configure-aws-credentials@v4 # 10 ç©ºæ ¼ç¼©è¿›
        with: # 10 ç©ºæ ¼ç¼©è¿›
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # 12 ç©ºæ ¼ç¼©è¿›
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ä¸‹è½½å¹¶æ¢å¤S3æ„å»ºç¯å¢ƒç¼“å­˜ (Download & Restore S3 Build Env Cache) # 8 ç©ºæ ¼ç¼©è¿›
        if: inputs.clean_build != 'true' # 10 ç©ºæ ¼ç¼©è¿›
        env: # 10 ç©ºæ ¼ç¼©è¿›
          S3_BUCKET_NAME_SECRET: ${{ secrets.AWS_S3_BUCKET_NAME }} # 12 ç©ºæ ¼ç¼©è¿›
          S3_ARCHIVE_NAME_ENV: ${{ env.S3_WORKSPACE_ARCHIVE_FILENAME }}
          RUNNER_WORKSPACE_PATH_ENV: ${{ env.RUNNER_OPENWRT_WORKSPACE }}
          DEBUG_LOG_FILE: ${{ env.DEBUG_LOG_ON_RUNNER }}
        run: | # 10 ç©ºæ ¼ç¼©è¿›, åç»­è„šæœ¬è¡Œä»12ç©ºæ ¼å¼€å§‹
          echo "S3_EFFECTIVE_PATH_PREFIX in download step: ${{ env.S3_EFFECTIVE_PATH_PREFIX }}" | tee -a "$DEBUG_LOG_FILE"
          if [ -z "$S3_BUCKET_NAME_SECRET" ]; then
            echo "[ERROR] AWS_S3_BUCKET_NAME secret æœªè®¾ç½®ã€‚è·³è¿‡S3ç¼“å­˜æ¢å¤ã€‚" | tee -a "$DEBUG_LOG_FILE"
            mkdir -p "$RUNNER_WORKSPACE_PATH_ENV"
            exit 0
          fi
          
          S3_OBJECT_KEY="${{ env.S3_EFFECTIVE_PATH_PREFIX }}/${S3_ARCHIVE_NAME_ENV}"
          LOCAL_ARCHIVE_ON_RUNNER="/tmp/${S3_ARCHIVE_NAME_ENV}"

          echo "å°è¯•ä» S3 ä¸‹è½½: s3://${S3_BUCKET_NAME_SECRET}/${S3_OBJECT_KEY} åˆ° ${LOCAL_ARCHIVE_ON_RUNNER} ..." | tee -a "$DEBUG_LOG_FILE"
          if aws s3 cp "s3://${S3_BUCKET_NAME_SECRET}/${S3_OBJECT_KEY}" "${LOCAL_ARCHIVE_ON_RUNNER}" --no-progress; then
            echo "ä¸‹è½½ ${S3_ARCHIVE_NAME_ENV} æˆåŠŸ. å¤§å°: $(du -sh ${LOCAL_ARCHIVE_ON_RUNNER} | awk '{print $1}')" | tee -a "$DEBUG_LOG_FILE"
            echo "å¼€å§‹è§£å‹åˆ° ${RUNNER_WORKSPACE_PATH_ENV} ..." | tee -a "$DEBUG_LOG_FILE"
            mkdir -p "${RUNNER_WORKSPACE_PATH_ENV}"
            rm -rf "${RUNNER_WORKSPACE_PATH_ENV:?}"/* "${RUNNER_WORKSPACE_PATH_ENV:?}"/.[!.]* "${RUNNER_WORKSPACE_PATH_ENV:?}"/..?* 2>/dev/null || true
            if tar -I "zstd -T0" -xf "${LOCAL_ARCHIVE_ON_RUNNER}" -C "${RUNNER_WORKSPACE_PATH_ENV}"; then
              echo "è§£å‹ ${S3_ARCHIVE_NAME_ENV} åˆ° ${RUNNER_WORKSPACE_PATH_ENV} æˆåŠŸã€‚" | tee -a "$DEBUG_LOG_FILE"
              echo "S3_CACHE_RESTORED=true" >> $GITHUB_ENV
            else
              echo "é”™è¯¯ï¼šè§£å‹ ${S3_ARCHIVE_NAME_ENV} å¤±è´¥ã€‚å°†è¿›è¡Œå…¨æ–°æ„å»ºã€‚" | tee -a "$DEBUG_LOG_FILE"
              rm -rf "${RUNNER_WORKSPACE_PATH_ENV:?}"/* "${RUNNER_WORKSPACE_PATH_ENV:?}"/.[!.]* "${RUNNER_WORKSPACE_PATH_ENV:?}"/..?* 2>/dev/null || true
            fi
            rm -f "${LOCAL_ARCHIVE_ON_RUNNER}"
          else
            echo "ä» S3 ä¸‹è½½ ${S3_ARCHIVE_NAME_ENV} å¤±è´¥æˆ–æ–‡ä»¶ä¸å­˜åœ¨ã€‚å°†è¿›è¡Œå…¨æ–°æ„å»ºã€‚" | tee -a "$DEBUG_LOG_FILE"
            mkdir -p "$RUNNER_WORKSPACE_PATH_ENV"
          fi
          df -h | tee -a "$DEBUG_LOG_FILE"
      
      # å…³é”®æ­¥éª¤ï¼šç¡®ä¿ä¸‹é¢çš„ 'run: |' å—å†…æ‰€æœ‰è¡Œï¼ˆåŒ…æ‹¬ DOCKER_SCRIPT_EOF å’Œ docker run çš„æ¯ä¸€è¡Œï¼‰
      # éƒ½ç²¾ç¡®åœ°ä»ç¬¬12ä¸ªç©ºæ ¼å¼€å§‹ã€‚
      # ä¸è¦æœ‰ä»»ä½• Tab å­—ç¬¦ï¼Œå…¨éƒ¨ä½¿ç”¨ç©ºæ ¼ã€‚
      - name: è¿è¡ŒDockerå®¹å™¨å¹¶æ‰§è¡Œç¼–è¯‘ (Run Docker Container & Compile) # 8 ç©ºæ ¼ç¼©è¿›
        id: compile_in_docker # 10 ç©ºæ ¼ç¼©è¿›
        run: | # 10 ç©ºæ ¼ç¼©è¿›, åç»­è„šæœ¬è¡Œä»12ç©ºæ ¼å¼€å§‹
          cat << 'DOCKER_SCRIPT_EOF' > /tmp/docker_build_script.sh
          #!/bin/bash
          set -eo pipefail

          echo "[DOCKER] Starting build script inside Docker container..."
          echo "[DOCKER] Runner's OpenWrt Workspace (mounted at ${DOCKER_ENV_CONTAINER_BUILD_AREA}): $(ls -A ${DOCKER_ENV_CONTAINER_BUILD_AREA} | wc -l) items"
          echo "[DOCKER] Repo Config Path (mounted at ${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}): $(ls -A ${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH} | wc -l) items"

          apt-get update -y && apt-get install -y --no-install-recommends \
            git build-essential libncurses5-dev libncursesw5-dev zlib1g-dev libssl-dev \
            subversion gawk wget curl python3 python3-distutils unzip file patch \
            rsync util-linux procps ccache libelf-dev libfuse-dev libglib2.0-dev \
            libgmp3-dev libltdl-dev libmpc-dev libmpfr-dev libreadline-dev libtool \
            llvm p7zip p7zip-full xsltproc xxd gettext autopoint \
            time
          apt-get clean && rm -rf /var/lib/apt/lists/*
          
          export TZ="${DOCKER_ENV_BUILD_TZ:-Asia/Shanghai}"
          ln -snf "/usr/share/zoneinfo/$TZ" /etc/localtime && echo "$TZ" > /etc/timezone
          
          mkdir -p "${DOCKER_ENV_CONTAINER_BUILD_AREA}"
          cd "${DOCKER_ENV_CONTAINER_BUILD_AREA}"
          echo "[DOCKER] Current directory: $(pwd)"

          INTERNAL_BUILD_STATE_DIR="./${DOCKER_ENV_BUILD_STATE_DIR_NAME:-.github_actions_build_state}"
          INTERNAL_CCACHE_DIR="./${DOCKER_ENV_CCACHE_DIR_NAME:-.ccache}"
          INTERNAL_CONFIG_FILE_NAME="${DOCKER_ENV_CONFIG_FILE_NAME_IN_REPO:-.config_default}"
          INTERNAL_DIY_P1_SH_NAME="${DOCKER_ENV_DIY_P1_SH_NAME_IN_REPO:-diy-p1-default.sh}"
          INTERNAL_DIY_P2_SH_NAME="${DOCKER_ENV_DIY_P2_SH_NAME_IN_REPO:-diy-p2-default.sh}"
          INTERNAL_DEBUG_LOG="${DOCKER_ENV_CONTAINER_DEBUG_LOG_PATH:-/tmp/container_build_debug.log}"
          INTERNAL_CCACHE_LOG="${DOCKER_ENV_CONTAINER_CCACHE_LOG_PATH:-/tmp/container_ccache_detailed.log}"

          mkdir -p "${INTERNAL_CCACHE_DIR}"
          export CCACHE_DIR="${INTERNAL_CCACHE_DIR}"
          export CCACHE_LOGFILE="${INTERNAL_CCACHE_LOG}"
          ccache -M 8G
          ccache -z

          if [ ! -d ".git" ] && [ ! -f "Makefile" ]; then
              echo "[DOCKER] Looks like a fresh setup. Cloning OpenWrt..." | tee -a "${INTERNAL_DEBUG_LOG}"
              git clone --depth 1 "${DOCKER_ENV_REPO_URL}" -b "${DOCKER_ENV_REPO_BRANCH}" .
          else
              echo "[DOCKER] Found existing OpenWrt tree." | tee -a "${INTERNAL_DEBUG_LOG}"
          fi
          
          mkdir -p "${INTERNAL_BUILD_STATE_DIR}" logs

          echo "[DOCKER] Copying config and DIY scripts from ${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH} ..." | tee -a "${INTERNAL_DEBUG_LOG}"
          cp "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/${INTERNAL_CONFIG_FILE_NAME}" "./.config"
          cp ./.config ./.config.input
          
          cp "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/${INTERNAL_DIY_P1_SH_NAME}" "./${INTERNAL_DIY_P1_SH_NAME}" && chmod +x "./${INTERNAL_DIY_P1_SH_NAME}"
          cp "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/${INTERNAL_DIY_P2_SH_NAME}" "./${INTERNAL_DIY_P2_SH_NAME}" && chmod +x "./${INTERNAL_DIY_P2_SH_NAME}"
          
          "./${INTERNAL_DIY_P1_SH_NAME}"

          if [ -f "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/feeds.conf.default" ]; then
            cp "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/feeds.conf.default" "./feeds.conf.default"
          elif [ ! -f "./feeds.conf.default" ] && [ -f "./feeds.conf.default.sample" ]; then
            cp feeds.conf.default.sample feeds.conf.default
          fi
          cat feeds.conf.default | tee -a "${INTERNAL_DEBUG_LOG}"

          ./scripts/feeds update -a
          ./scripts/feeds install -a

          "./${INTERNAL_DIY_P2_SH_NAME}"
          
          echo "CONFIG_AUTOREMOVE=y" >> .config
          echo "CONFIG_AUTOREBUILD=y" >> .config
          if ! grep -q "CONFIG_TARGET_ROOTFS_SQUASHFS=y" .config; then echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config; fi
          if ! grep -q "CONFIG_TARGET_IMAGES_GZIP=y" .config; then echo "CONFIG_TARGET_IMAGES_GZIP=y" >> .config; fi

          echo "[DOCKER] Running make defconfig..." | tee -a "${INTERNAL_DEBUG_LOG}"
          make defconfig
          
          TOOLCHAIN_CONFIG_SUBSET_FOR_MD5=$(grep -E "^CONFIG_TARGET|^CONFIG_ARCH|^CONFIG_TOOLCHAIN" .config | grep -v "NOT_SET" | sort)
          TOOLCHAIN_MD5=$(echo "$TOOLCHAIN_CONFIG_SUBSET_FOR_MD5" | md5sum | awk '{print $1}')
          PREVIOUS_TOOLCHAIN_MD5=$(cat ${INTERNAL_BUILD_STATE_DIR}/toolchain.md5 2>/dev/null || echo "not_found_in_build_state")

          PACKAGE_CONFIG_SUBSET_FOR_MD5=$(grep "^CONFIG_PACKAGE_" .config | grep "=y" | sort)
          PACKAGE_MD5=$(echo "$PACKAGE_CONFIG_SUBSET_FOR_MD5" | md5sum | awk '{print $1}')
          PREVIOUS_PACKAGE_MD5=$(cat ${INTERNAL_BUILD_STATE_DIR}/package.md5 2>/dev/null || echo "not_found_in_build_state")
          
          DO_FULL_BUILD_DOCKER=0
          DO_PACKAGE_BUILD_DOCKER=0

          echo "[DOCKER] --- Build Decision Variables ---" | tee -a "${INTERNAL_DEBUG_LOG}"
          echo "[DOCKER] Input clean_build (from outside): ${DOCKER_ENV_CLEAN_BUILD_FROM_OUTSIDE}" | tee -a "${INTERNAL_DEBUG_LOG}"
          echo "[DOCKER] S3 Cache Restored (from outside): ${DOCKER_ENV_S3_CACHE_RESTORED_FROM_OUTSIDE}" | tee -a "${INTERNAL_DEBUG_LOG}"
          echo "[DOCKER] Feeds changed (from outside): ${DOCKER_ENV_FEEDS_CHANGED_FROM_OUTSIDE}" | tee -a "${INTERNAL_DEBUG_LOG}"

          if [ "${DOCKER_ENV_CLEAN_BUILD_FROM_OUTSIDE}" = "true" ] || [ "${DOCKER_ENV_S3_CACHE_RESTORED_FROM_OUTSIDE}" != "true" ] ; then
            echo "[DOCKER] clean_build is true OR S3 cache not restored: DO_FULL_BUILD_DOCKER=1" | tee -a "${INTERNAL_DEBUG_LOG}"
            DO_FULL_BUILD_DOCKER=1
          elif [ "$PREVIOUS_TOOLCHAIN_MD5" = "not_found_in_build_state" ] || [ "$TOOLCHAIN_MD5" != "$PREVIOUS_TOOLCHAIN_MD5" ]; then
            echo "[DOCKER] Toolchain config MD5 changed or first build state: DO_FULL_BUILD_DOCKER=1" | tee -a "${INTERNAL_DEBUG_LOG}"
            DO_FULL_BUILD_DOCKER=1
          elif [ "$PREVIOUS_PACKAGE_MD5" = "not_found_in_build_state" ] || [ "$PACKAGE_MD5" != "$PREVIOUS_PACKAGE_MD5" ]; then
            echo "[DOCKER] Package config MD5 changed: DO_PACKAGE_BUILD_DOCKER=1" | tee -a "${INTERNAL_DEBUG_LOG}"
            DO_PACKAGE_BUILD_DOCKER=1
          elif [ "${DOCKER_ENV_FEEDS_CHANGED_FROM_OUTSIDE}" = "true" ]; then
            echo "[DOCKER] Feeds changed: DO_PACKAGE_BUILD_DOCKER=1" | tee -a "${INTERNAL_DEBUG_LOG}"
            DO_PACKAGE_BUILD_DOCKER=1
          fi
          echo "[DOCKER] Final Build Strategy -> DO_FULL_BUILD_DOCKER: $DO_FULL_BUILD_DOCKER, DO_PACKAGE_BUILD_DOCKER: $DO_PACKAGE_BUILD_DOCKER" | tee -a "${INTERNAL_DEBUG_LOG}"
          
          MAKE_JOBS_DOCKER=$(nproc)
          MAIN_MAKE_CMD_DOCKER="make -j${MAKE_JOBS_DOCKER} V=s"
          FALLBACK_MAKE_CMD_DOCKER="make -j1 V=s"
          COMPILE_OUTPUT_LOG_DOCKER="logs/compile_output_docker_$(date +%Y%m%d_%H%M%S).log"
          echo "[DOCKER] Detailed compile log will be in: ${DOCKER_ENV_CONTAINER_BUILD_AREA}/${COMPILE_OUTPUT_LOG_DOCKER}" | tee -a "${INTERNAL_DEBUG_LOG}"

          if [ $DO_FULL_BUILD_DOCKER -eq 1 ]; then
            echo "[DOCKER] --- Compile Branch: Full Build ---" | tee -a "${INTERNAL_DEBUG_LOG}"
            make tools/compile $FALLBACK_MAKE_CMD_DOCKER || make tools/compile $FALLBACK_MAKE_CMD_DOCKER
            make toolchain/compile $FALLBACK_MAKE_CMD_DOCKER || make toolchain/compile $FALLBACK_MAKE_CMD_DOCKER
            if ! $MAIN_MAKE_CMD_DOCKER 2>&1 | tee "${COMPILE_OUTPUT_LOG_DOCKER}"; then $FALLBACK_MAKE_CMD_DOCKER 2>&1 | tee -a "${COMPILE_OUTPUT_LOG_DOCKER}"; fi
          elif [ $DO_PACKAGE_BUILD_DOCKER -eq 1 ]; then
            echo "[DOCKER] --- Compile Branch: Package Build ---" | tee -a "${INTERNAL_DEBUG_LOG}"
            make package/clean V=s || true
            if ! make package/compile $MAIN_MAKE_CMD_DOCKER 2>&1 | tee "${COMPILE_OUTPUT_LOG_DOCKER}"; then make package/compile $FALLBACK_MAKE_CMD_DOCKER 2>&1 | tee -a "${COMPILE_OUTPUT_LOG_DOCKER}"; fi
            make package/index V=s || make package/index $FALLBACK_MAKE_CMD_DOCKER
          else
            echo "[DOCKER] --- Compile Branch: Minimal Incremental Build ---" | tee -a "${INTERNAL_DEBUG_LOG}"
            if ! $MAIN_MAKE_CMD_DOCKER 2>&1 | tee "${COMPILE_OUTPUT_LOG_DOCKER}"; then $FALLBACK_MAKE_CMD_DOCKER 2>&1 | tee -a "${COMPILE_OUTPUT_LOG_DOCKER}"; fi
          fi
          
          echo "[DOCKER] Finalizing target/install..." | tee -a "${INTERNAL_DEBUG_LOG}"
          make target/install $FALLBACK_MAKE_CMD_DOCKER 2>&1 | tee -a "${COMPILE_OUTPUT_LOG_DOCKER}"
          final_install_status_docker=$?

          echo "[DOCKER] Attempting to finalize core component stamps..." | tee -a "${INTERNAL_DEBUG_LOG}"
          make prepare -j${MAKE_JOBS_DOCKER} V=s || make prepare -j1 V=s || echo "[DOCKER_WARN] 'make prepare' had issues." | tee -a "${INTERNAL_DEBUG_LOG}"
          make tools/install -j${MAKE_JOBS_DOCKER} V=s IGNORE_ERRORS=m || make tools/install -j1 V=s IGNORE_ERRORS=m || echo "[DOCKER_WARN] 'make tools/install' had issues." | tee -a "${INTERNAL_DEBUG_LOG}"
          make toolchain/install -j${MAKE_JOBS_DOCKER} V=s IGNORE_ERRORS=m || make toolchain/install -j1 V=s IGNORE_ERRORS=m || echo "[DOCKER_WARN] 'make toolchain/install' had issues." | tee -a "${INTERNAL_DEBUG_LOG}"
          echo "[DOCKER] Core component stamp finalization attempted." | tee -a "${INTERNAL_DEBUG_LOG}"

          mkdir -p "${INTERNAL_BUILD_STATE_DIR}"
          cp .config "${INTERNAL_BUILD_STATE_DIR}/config_from_compile_step.txt"
          echo "$TOOLCHAIN_MD5" > "${INTERNAL_BUILD_STATE_DIR}/toolchain.md5"
          echo "$PACKAGE_MD5" > "${INTERNAL_BUILD_STATE_DIR}/package.md5"
          echo "${DOCKER_ENV_FEEDS_CHANGED_FROM_OUTSIDE}" > "${INTERNAL_BUILD_STATE_DIR}/last_feeds_changed_status.txt"
          find feeds -type f -name "Makefile" -exec sha256sum {} \; | sort | sha256sum > "${INTERNAL_BUILD_STATE_DIR}/current_feeds.sha256"

          echo "[DOCKER] >>> CCACHE Statistics at END of compile_firmware:" | tee -a "${INTERNAL_DEBUG_LOG}"
          ccache -s | tee -a "${INTERNAL_DEBUG_LOG}"

          if [ ${final_install_status_docker} -eq 0 ] && [ -n "$(find bin/targets -type f \( -name "*.bin" -o -name "*combined*" -o -name "*sysupgrade*" -o -name "*.img.gz" \) -print -quit)" ]; then
            echo "[DOCKER] Compile firmware successful." | tee -a "${INTERNAL_DEBUG_LOG}"
            touch "${DOCKER_ENV_CONTAINER_BUILD_AREA}/.docker_build_status_success"
          else
            echo "[DOCKER] Compile firmware failed." | tee -a "${INTERNAL_DEBUG_LOG}"
            touch "${DOCKER_ENV_CONTAINER_BUILD_AREA}/.docker_build_status_failure"
          fi
          cp "${INTERNAL_DEBUG_LOG}" "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/docker_build_debug_summary.log" || true
          cp "${INTERNAL_CCACHE_LOG}" "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/docker_ccache_detailed.log" || true
          if [ -f "${COMPILE_OUTPUT_LOG_DOCKER}" ]; then
            cp "${COMPILE_OUTPUT_LOG_DOCKER}" "${DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH}/docker_compile_output.log" || true
          fi

          echo "[DOCKER] Build script finished."
          DOCKER_SCRIPT_EOF
          # ^^^^ The above DOCKER_SCRIPT_EOF MUST have the same leading whitespace as the `cat << ...` line (e.g., 12 spaces from file start if run: is at 10).
          # AND no characters after DOCKER_SCRIPT_EOF on this line.

          chmod +x /tmp/docker_build_script.sh

          docker run --rm \
            -v "${{ env.RUNNER_OPENWRT_WORKSPACE }}:${{ env.CONTAINER_BUILD_AREA }}" \
            -v "${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}:${{ env.CONTAINER_REPO_CONFIG_MOUNT }}:ro" \
            -e DOCKER_ENV_REPO_URL="${{ env.REPO_URL }}" \
            -e DOCKER_ENV_REPO_BRANCH="${{ env.REPO_BRANCH }}" \
            -e DOCKER_ENV_FEEDS_CONF_URL="${{ env.FEEDS_CONF_URL }}" \
            -e DOCKER_ENV_CONFIG_FILE_NAME_IN_REPO="${{ env.CONFIG_FILE_IN_REPO }}" \
            -e DOCKER_ENV_DIY_P1_SH_NAME_IN_REPO="${{ env.DIY_P1_SH_IN_REPO }}" \
            -e DOCKER_ENV_DIY_P2_SH_NAME_IN_REPO="${{ env.DIY_P2_SH_IN_REPO }}" \
            -e DOCKER_ENV_BUILD_STATE_DIR_NAME="${{ env.BUILD_STATE_DIR_NAME }}" \
            -e DOCKER_ENV_CCACHE_DIR_NAME="${{ env.CCACHE_DIR_NAME }}" \
            -e DOCKER_ENV_CONTAINER_DEBUG_LOG_PATH="${{ env.CONTAINER_DEBUG_LOG_FILE_PATH }}" \
            -e DOCKER_ENV_CONTAINER_CCACHE_LOG_PATH="${{ env.CONTAINER_CCACHE_LOGFILE_PATH }}" \
            -e DOCKER_ENV_CONTAINER_BUILD_AREA="${{ env.CONTAINER_BUILD_AREA }}" \
            -e DOCKER_ENV_CONTAINER_REPO_CONFIG_PATH="${{ env.CONTAINER_REPO_CONFIG_MOUNT }}" \
            -e DOCKER_ENV_CLEAN_BUILD_FROM_OUTSIDE="${{ github.event.inputs.clean_build }}" \
            -e DOCKER_ENV_S3_CACHE_RESTORED_FROM_OUTSIDE="${{ env.S3_CACHE_RESTORED || 'false' }}" \
            -e DOCKER_ENV_FEEDS_CHANGED_FROM_OUTSIDE="${{ env.feeds_changed || 'true' }}" \
            -e DOCKER_ENV_BUILD_TZ="${{ env.TZ }}" \
            ${{ env.DOCKER_IMAGE }} \
            bash -c "cd \"${DOCKER_ENV_CONTAINER_BUILD_AREA}\" && /tmp/docker_build_script.sh"
          
          if [ -f "${{ env.RUNNER_OPENWRT_WORKSPACE }}/.docker_build_status_success" ]; then
              echo "Docker build reported success."
              echo "status=success" >> $GITHUB_OUTPUT
              rm -f "${{ env.RUNNER_OPENWRT_WORKSPACE }}/.docker_build_status_success"
          else
              echo "Docker build reported failure or marker not found."
              echo "status=failure" >> $GITHUB_OUTPUT
              rm -f "${{ env.RUNNER_OPENWRT_WORKSPACE }}/.docker_build_status_failure" 2>/dev/null || true
              echo "Copying out logs from Docker mapped repo config (if any)..."
              cp "${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}/docker_build_debug_summary.log" "/tmp/docker_build_debug_summary_runner.log" 2>/dev/null || true
              cp "${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}/docker_ccache_detailed.log" "/tmp/docker_ccache_detailed_runner.log" 2>/dev/null || true
              cp "${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}/docker_compile_output.log" "/tmp/docker_compile_output_runner.log" 2>/dev/null || true
          fi
          rm -f /tmp/docker_build_script.sh

      - name: æ‰“åŒ…å¹¶ä¸Šä¼ S3æ„å»ºç¯å¢ƒç¼“å­˜ (Pack & Upload S3 Build Environment Cache) # 8 ç©ºæ ¼ç¼©è¿›
        if: steps.compile_in_docker.outputs.status == 'success' && !cancelled() # 10 ç©ºæ ¼ç¼©è¿›
        env: # 10 ç©ºæ ¼ç¼©è¿›
          S3_BUCKET_NAME_SECRET: ${{ secrets.AWS_S3_BUCKET_NAME }} # 12 ç©ºæ ¼ç¼©è¿›
          S3_ARCHIVE_NAME_ENV: ${{ env.S3_WORKSPACE_ARCHIVE_FILENAME }}
          RUNNER_WORKSPACE_PATH_ENV: ${{ env.RUNNER_OPENWRT_WORKSPACE }}
          S3_CONFIG_SNAPSHOT_FILENAME_ENV: ${{ env.S3_CONFIG_SNAPSHOT_FILENAME }}
          DEBUG_LOG_FILE: ${{ env.DEBUG_LOG_ON_RUNNER }}
        run: | # 10 ç©ºæ ¼ç¼©è¿›, åç»­è„šæœ¬è¡Œä»12ç©ºæ ¼å¼€å§‹
          echo "S3_EFFECTIVE_PATH_PREFIX in upload step: ${{ env.S3_EFFECTIVE_PATH_PREFIX }}" | tee -a "$DEBUG_LOG_FILE"
          if [ -z "$S3_BUCKET_NAME_SECRET" ]; then
            echo "[ERROR] AWS_S3_BUCKET_NAME secret æœªè®¾ç½®ã€‚æ— æ³•ä¸Šä¼ ç¼“å­˜åˆ°S3ã€‚" | tee -a "$DEBUG_LOG_FILE"
            exit 1
          fi
          
          echo "å¼€å§‹æ‰“åŒ…å‹ç¼©æ•´ä¸ªå·¥ä½œåŒº: ${RUNNER_WORKSPACE_PATH_ENV} ä¸º /tmp/${S3_ARCHIVE_NAME_ENV} ..." | tee -a "$DEBUG_LOG_FILE"
          PARENT_DIR_OF_WORKSPACE=$(dirname "${RUNNER_WORKSPACE_PATH_ENV}")
          BASENAME_OF_WORKSPACE=$(basename "${RUNNER_WORKSPACE_PATH_ENV}")

          if tar -I "zstd -T0 -3" -cf "/tmp/${S3_ARCHIVE_NAME_ENV}" -C "${PARENT_DIR_OF_WORKSPACE}" "${BASENAME_OF_WORKSPACE}"; then
            ARCHIVE_SIZE=$(du -sh "/tmp/${S3_ARCHIVE_NAME_ENV}" | awk '{print $1}')
            echo "æ‰“åŒ…å‹ç¼© /tmp/${S3_ARCHIVE_NAME_ENV} æˆåŠŸ. æ–‡ä»¶å¤§å°: $ARCHIVE_SIZE" | tee -a "$DEBUG_LOG_FILE"
            
            S3_OBJECT_KEY="${{ env.S3_EFFECTIVE_PATH_PREFIX }}/${S3_ARCHIVE_NAME_ENV}"
            echo "å¼€å§‹ä¸Šä¼  /tmp/${S3_ARCHIVE_NAME_ENV} åˆ° s3://${S3_BUCKET_NAME_SECRET}/${S3_OBJECT_KEY} ..." | tee -a "$DEBUG_LOG_FILE"
            if aws s3 cp "/tmp/${S3_ARCHIVE_NAME_ENV}" "s3://${S3_BUCKET_NAME_SECRET}/${S3_OBJECT_KEY}" --quiet; then
              echo "ä¸Šä¼  /tmp/${S3_ARCHIVE_NAME_ENV} åˆ° S3 æˆåŠŸã€‚" | tee -a "$DEBUG_LOG_FILE"
            else
              echo "é”™è¯¯ï¼šä¸Šä¼  /tmp/${S3_ARCHIVE_NAME_ENV} åˆ° S3 å¤±è´¥ã€‚" | tee -a "$DEBUG_LOG_FILE"
            fi
            rm -f "/tmp/${S3_ARCHIVE_NAME_ENV}"
          else
            echo "é”™è¯¯ï¼šæ‰“åŒ…å‹ç¼© ${RUNNER_WORKSPACE_PATH_ENV} å¤±è´¥ã€‚" | tee -a "$DEBUG_LOG_FILE"
          fi

          CONFIG_FILE_IN_WORKSPACE="${RUNNER_WORKSPACE_PATH_ENV}/.config"
          if [ -f "$CONFIG_FILE_IN_WORKSPACE" ]; then
            echo "ä¸Šä¼  .config æ–‡ä»¶ (${CONFIG_FILE_IN_WORKSPACE}) åˆ° S3..." | tee -a "$DEBUG_LOG_FILE"
            S3_CONFIG_OBJECT_KEY="${{ env.S3_EFFECTIVE_PATH_PREFIX }}/${S3_CONFIG_SNAPSHOT_FILENAME_ENV}"
            if aws s3 cp "$CONFIG_FILE_IN_WORKSPACE" "s3://${S3_BUCKET_NAME_SECRET}/${S3_CONFIG_OBJECT_KEY}" --quiet; then
              echo ".config æ–‡ä»¶æˆåŠŸä¸Šä¼ åˆ° s3://${S3_BUCKET_NAME_SECRET}/${S3_CONFIG_OBJECT_KEY}" | tee -a "$DEBUG_LOG_FILE"
            else
              echo "é”™è¯¯ï¼šä¸Šä¼  .config æ–‡ä»¶åˆ° S3 å¤±è´¥ã€‚" | tee -a "$DEBUG_LOG_FILE"
            fi
          else
            echo "è­¦å‘Šï¼š${CONFIG_FILE_IN_WORKSPACE} æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œæ— æ³•ä¸Šä¼ åˆ°S3ã€‚" | tee -a "$DEBUG_LOG_FILE"
          fi

      - name: Upload Debug Logs (from Runner and potentially Docker) # 8 ç©ºæ ¼ç¼©è¿›
        if: always() # 10 ç©ºæ ¼ç¼©è¿›
        uses: actions/upload-artifact@main # 10 ç©ºæ ¼ç¼©è¿›
        with: # 10 ç©ºæ ¼ç¼©è¿›
          name: build-debug-logs-${{ github.run_id }} # 12 ç©ºæ ¼ç¼©è¿›
          path: | # 12 ç©ºæ ¼ç¼©è¿›, åç»­è·¯å¾„ä»14ç©ºæ ¼å¼€å§‹
            ${{ env.DEBUG_LOG_ON_RUNNER }}
            ${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}/docker_build_debug_summary.log
            ${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}/docker_ccache_detailed.log
            ${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}/docker_compile_output.log
            ${{ env.RUNNER_OPENWRT_WORKSPACE }}/config_diff.txt
            ${{ env.RUNNER_OPENWRT_WORKSPACE }}/.config
            ${{ env.RUNNER_OPENWRT_WORKSPACE }}/.config.input
            ${{ env.RUNNER_OPENWRT_WORKSPACE }}/logs/
          if-no-files-found: ignore # 12 ç©ºæ ¼ç¼©è¿›
          retention-days: 7 # 12 ç©ºæ ¼ç¼©è¿›

      - name: æ•´ç†æ–‡ä»¶ (Organize Firmware Files) # 8 ç©ºæ ¼ç¼©è¿›
        id: organize # 10 ç©ºæ ¼ç¼©è¿›
        if: steps.compile_in_docker.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true' && !cancelled() # 10 ç©ºæ ¼ç¼©è¿›
        run: | # 10 ç©ºæ ¼ç¼©è¿›, åç»­è„šæœ¬è¡Œä»12ç©ºæ ¼å¼€å§‹
          echo "å¼€å§‹æ•´ç†å›ºä»¶æ–‡ä»¶ from ${{ env.RUNNER_OPENWRT_WORKSPACE }}/bin ..." | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
          FIRMWARE_COLLECTION_DIR_PATH=""
          OPENWRT_BUILD_ROOT="${{ env.RUNNER_OPENWRT_WORKSPACE }}"
          OPENWRT_BIN_DIR="${OPENWRT_BUILD_ROOT}/bin"
          OPENWRT_TARGETS_DIR="${OPENWRT_BIN_DIR}/targets"

          if [ ! -d "${OPENWRT_TARGETS_DIR}" ]; then
            echo "é”™è¯¯ï¼šç¼–è¯‘ç›®æ ‡ç›®å½• ${OPENWRT_TARGETS_DIR} ä¸å­˜åœ¨ã€‚" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
            FIRMWARE_COLLECTION_DIR_PATH="/tmp/empty_firmware_collection_$(date +%N)"
            mkdir -p "${FIRMWARE_COLLECTION_DIR_PATH}"
            echo "FIRMWARE=${FIRMWARE_COLLECTION_DIR_PATH}" >> $GITHUB_ENV
            echo "status=success" >> $GITHUB_OUTPUT
            echo "FIRMWARE_ZIP=${FIRMWARE_COLLECTION_DIR_PATH}.zip" >> $GITHUB_ENV
            zip -r9 "${FIRMWARE_COLLECTION_DIR_PATH}.zip" "${FIRMWARE_COLLECTION_DIR_PATH}"
            exit 0
          fi

          DEEPEST_TARGET_SUBDIRS=$(find "${OPENWRT_TARGETS_DIR}" -mindepth 2 -maxdepth 2 -type d ! -name "packages" -print)
          if [ -z "${DEEPEST_TARGET_SUBDIRS}" ]; then
              echo "è­¦å‘Šï¼šåœ¨ ${OPENWRT_TARGETS_DIR} ä¸‹æœªæ‰¾åˆ°æ ‡å‡†çš„ç›®æ ‡æ¶æ„å­ç›®å½•ã€‚å°è¯•ç›´æ¥åœ¨ ${OPENWRT_TARGETS_DIR} æœç´¢ã€‚" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
              DEEPEST_TARGET_SUBDIRS="${OPENWRT_TARGETS_DIR}"
          fi
          
          FINAL_FIRMWARE_OUTPUT_BASE="/tmp/firmware_output_collections"
          mkdir -p "$FINAL_FIRMWARE_OUTPUT_BASE"

          for CURRENT_IMG_SOURCE_DIR in $DEEPEST_TARGET_SUBDIRS; do
              echo "æ£€æŸ¥ç›®å½•: ${CURRENT_IMG_SOURCE_DIR} ä¸­çš„å›ºä»¶æ–‡ä»¶..." | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
              COLLECTED_FIRMWARE_OUTPUT_DIR="${FINAL_FIRMWARE_OUTPUT_BASE}/firmware_collection_$(basename "${CURRENT_IMG_SOURCE_DIR}")_$(date +%N)"
              mkdir -p "${COLLECTED_FIRMWARE_OUTPUT_DIR}"
              FILES_COPIED_COUNT=0
              
              cd "${CURRENT_IMG_SOURCE_DIR}"
              
              for pattern in "*combined.img.gz" "*sysupgrade.img.gz" "*combined-efi.img.gz" "*kernel.bin" "*.img" "*.bin"; do
                  find . -maxdepth 1 -type f -name "$pattern" ! -path "./packages/*" -print0 | while IFS= read -r -d $'\0' found_file; do
                      cp -v -f "${found_file}" "${COLLECTED_FIRMWARE_OUTPUT_DIR}/"
                      FILES_COPIED_COUNT=$((FILES_COPIED_COUNT + 1))
                  done
              done
              
              if [ $FILES_COPIED_COUNT -eq 0 ]; then
                  echo "åœ¨ ${CURRENT_IMG_SOURCE_DIR} ä¸­æœªæ‰¾åˆ°æ ‡å‡†æ¨¡å¼çš„å›ºä»¶ï¼Œå°è¯•å¤åˆ¶å…¶ä»–å¯èƒ½çš„æ–‡ä»¶..." | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
                  find . -maxdepth 1 -type f \
                    ! -name "*.manifest" ! -name "*.txt" ! -name "*.json" ! -name "*.buildinfo" ! -name "sha256sums" \
                    ! -path "./packages/*" \
                    -print0 | while IFS= read -r -d $'\0' found_file; do
                      cp -v -f "${found_file}" "${COLLECTED_FIRMWARE_OUTPUT_DIR}/"
                      FILES_COPIED_COUNT=$((FILES_COPIED_COUNT + 1))
                  done
              fi
              cd "${{ github.workspace }}/${{ env.RUNNER_CHECKOUT_SUBDIR }}"

              if [ $FILES_COPIED_COUNT -gt 0 ]; then
                  echo "æˆåŠŸä» ${CURRENT_IMG_SOURCE_DIR} å¤åˆ¶ $FILES_COPIED_COUNT ä¸ªæ–‡ä»¶åˆ° ${COLLECTED_FIRMWARE_OUTPUT_DIR}" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
                  if [ -f "${OPENWRT_BUILD_ROOT}/.config" ]; then
                    cp -v -f "${OPENWRT_BUILD_ROOT}/.config" "${COLLECTED_FIRMWARE_OUTPUT_DIR}/config.txt"
                  fi
                  ls -lh "${COLLECTED_FIRMWARE_OUTPUT_DIR}" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
                  FIRMWARE_COLLECTION_DIR_PATH="${COLLECTED_FIRMWARE_OUTPUT_DIR}"
                  break
              else
                  echo "è­¦å‘Š: åœ¨ ${CURRENT_IMG_SOURCE_DIR} ä¸­æœªæ‰¾åˆ°å¯ç”¨å›ºä»¶æ–‡ä»¶å¯æ”¶é›†ã€‚" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
                  rm -rf "${COLLECTED_FIRMWARE_OUTPUT_DIR}"
              fi
          done

          if [ -z "${FIRMWARE_COLLECTION_DIR_PATH}" ]; then
              echo "è­¦å‘Šï¼šæœªèƒ½åœ¨ä»»ä½•æ ‡å‡†ç›®æ ‡å­ç›®å½•ä¸­æ”¶é›†åˆ°å›ºä»¶æ–‡ä»¶ã€‚å¯ç”¨ç´§æ€¥å¤‡ç”¨æ”¶é›†é€»è¾‘ã€‚" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
              FIRMWARE_COLLECTION_DIR_PATH="${FINAL_FIRMWARE_OUTPUT_BASE}/firmware_fallback_collection_$(date +%N)"
              mkdir -p "${FIRMWARE_COLLECTION_DIR_PATH}"
              find "${OPENWRT_TARGETS_DIR}" -type f \( -name "*.bin" -o -name "*.img" -o -name "*.img.gz" \) ! -path "*/packages/*" ! -path "*/firmware_collection_*" -exec cp -v -f {} "${FIRMWARE_COLLECTION_DIR_PATH}/" \;
              if [ -f "${OPENWRT_BUILD_ROOT}/.config" ]; then
                  cp -v -f "${OPENWRT_BUILD_ROOT}/.config" "${FIRMWARE_COLLECTION_DIR_PATH}/config.txt";
              else
                  echo "# Fallback .config - actual .config not found" > "${FIRMWARE_COLLECTION_DIR_PATH}/config.txt";
              fi
          fi

          echo "FIRMWARE=${FIRMWARE_COLLECTION_DIR_PATH}" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT

          if [ -n "${FIRMWARE_COLLECTION_DIR_PATH}" ] && [ -d "${FIRMWARE_COLLECTION_DIR_PATH}" ] && [ "$(ls -A "${FIRMWARE_COLLECTION_DIR_PATH}")" ]; then
              FIRMWARE_PARENT_DIR=$(dirname "${FIRMWARE_COLLECTION_DIR_PATH}")
              FIRMWARE_BASENAME=$(basename "${FIRMWARE_COLLECTION_DIR_PATH}")
              ZIP_FILENAME="${FIRMWARE_BASENAME}.zip"
              
              echo "åˆ›å»ºå›ºä»¶å‹ç¼©åŒ… ${FIRMWARE_PARENT_DIR}/${ZIP_FILENAME} ä»ç›®å½• ${FIRMWARE_BASENAME}" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
              cd "${FIRMWARE_PARENT_DIR}" && zip -r9 "${ZIP_FILENAME}" "${FIRMWARE_BASENAME}"
              
              if [ -f "${ZIP_FILENAME}" ]; then
                  echo "FIRMWARE_ZIP=${FIRMWARE_PARENT_DIR}/${ZIP_FILENAME}" >> $GITHUB_ENV
                  ls -lh "${FIRMWARE_PARENT_DIR}/${ZIP_FILENAME}" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
              else
                  echo "é”™è¯¯ï¼šå‹ç¼©åŒ… ${ZIP_FILENAME} æœªèƒ½æˆåŠŸåˆ›å»ºã€‚" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
                  echo "FIRMWARE_ZIP=/tmp/zip_creation_failed_$(date +%N).zip" >> $GITHUB_ENV
              fi
          else
              echo "è­¦å‘Š: æœ€ç»ˆå›ºä»¶æ”¶é›†ç›®å½• (${FIRMWARE_COLLECTION_DIR_PATH}) æœªæœ‰æ•ˆè®¾ç½®ã€ä¸æ˜¯ç›®å½•æˆ–ä¸ºç©ºï¼Œæ— æ³•åˆ›å»º firmware.zipã€‚" | tee -a "${{ env.DEBUG_LOG_ON_RUNNER }}"
              echo "FIRMWARE_ZIP=/tmp/no_firmware_to_zip_$(date +%N).zip" >> $GITHUB_ENV
          fi

      - name: ä¸Šä¼ å›ºä»¶ (Artifact) # 8 ç©ºæ ¼ç¼©è¿›
        uses: actions/upload-artifact@main # 10 ç©ºæ ¼ç¼©è¿›
        if: steps.organize.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true' && !cancelled() # 10 ç©ºæ ¼ç¼©è¿›
        with: # 10 ç©ºæ ¼ç¼©è¿›
          name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }} # 12 ç©ºæ ¼ç¼©è¿›
          path: ${{ env.FIRMWARE_ZIP }}
          if-no-files-found: warn

      - name: ç”Ÿæˆå‘å¸ƒæ ‡ç­¾ (Generate Release Tag) # 8 ç©ºæ ¼ç¼©è¿›
        id: tag # 10 ç©ºæ ¼ç¼©è¿›
        if: steps.organize.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true' && !cancelled() # 10 ç©ºæ ¼ç¼©è¿›
        run: | # 10 ç©ºæ ¼ç¼©è¿›, åç»­è„šæœ¬è¡Œä»12ç©ºæ ¼å¼€å§‹
          RELEASE_TAG_BASE=$(date +"%Y.%m.%d-%H%M")
          DEVICE_TAG_PART=$(echo "${{ env.DEVICE_NAME }}" | sed 's/^_//;s/_$//' | sed 's/[^a-zA-Z0-9._-]/-/g' )
          if [ -n "$DEVICE_TAG_PART" ] && [ "$DEVICE_TAG_PART" != "-" ]; then FINAL_RELEASE_TAG="${RELEASE_TAG_BASE}_${DEVICE_TAG_PART}"; else FINAL_RELEASE_TAG="${RELEASE_TAG_BASE}"; fi
          echo "RELEASE_TAG=${FINAL_RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "## OpenWrt Firmware Build ($(date +"%Y-%m-%d %H:%M %Z")) ğŸ“¦" > release_body.txt
          echo "" >> release_body.txt
          echo "**Branch:** \`${{ env.REPO_BRANCH }}\`" >> release_body.txt
          echo "**Config:** \`${{ env.CONFIG_FILE_IN_REPO }}\`" >> release_body.txt
          if [ -n "$DEVICE_TAG_PART" ] && [ "$DEVICE_TAG_PART" != "-" ]; then echo "**Device:** \`${{ env.DEVICE_NAME }}\`" >> release_body.txt; fi
          echo "" >> release_body.txt
          echo "### å›ºä»¶ä¸‹è½½ (Firmware Download)" >> release_body.txt
          echo "è¯·åœ¨ä¸‹æ–¹ Assets ä¸­æ‰¾åˆ°å›ºä»¶æ–‡ä»¶ (é€šå¸¸æ˜¯ä¸€ä¸ª .zip å‹ç¼©åŒ…)ã€‚" >> release_body.txt
          echo "Please find firmware files (usually a .zip archive) in the Assets section below." >> release_body.txt
          echo "" >> release_body.txt; echo "---" >> release_body.txt
          echo "âš ï¸ **åˆ·æœºå‰è¯·åŠ¡å¿…å¤‡ä»½é‡è¦æ•°æ®ï¼**" >> release_body.txt
          echo "âš ï¸ **Backup your important data before flashing!**" >> release_body.txt
          echo "" >> release_body.txt
          echo "_Built by GitHub Actions - Workflow: [${{ github.workflow }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})_" >> release_body.txt
          echo "status=success" >> $GITHUB_OUTPUT

      - name: ä¸Šä¼ å›ºä»¶åˆ°Releases (Upload Firmware to Releases) # 8 ç©ºæ ¼ç¼©è¿›
        uses: softprops/action-gh-release@v2 # 10 ç©ºæ ¼ç¼©è¿›
        if: steps.tag.outputs.status == 'success' && !cancelled() # 10 ç©ºæ ¼ç¼©è¿›
        env: # 10 ç©ºæ ¼ç¼©è¿›
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 12 ç©ºæ ¼ç¼©è¿›
        with: # 10 ç©ºæ ¼ç¼©è¿›
          tag_name: ${{ steps.tag.outputs.RELEASE_TAG }} # 12 ç©ºæ ¼ç¼©è¿›
          body_path: release_body.txt
          files: ${{ env.FIRMWARE_ZIP }}

      - name: åˆ é™¤æ—§çš„Releases (Delete Old Releases) # 8 ç©ºæ ¼ç¼©è¿›
        uses: dev-drprasad/delete-older-releases@master # 10 ç©ºæ ¼ç¼©è¿›
        if: env.UPLOAD_RELEASE == 'true' && !cancelled() # 10 ç©ºæ ¼ç¼©è¿›
        with: # 10 ç©ºæ ¼ç¼©è¿›
          keep_latest: 3 # 12 ç©ºæ ¼ç¼©è¿›
          delete_tags: true
        env: # 10 ç©ºæ ¼ç¼©è¿›
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 12 ç©ºæ ¼ç¼©è¿›
