name: å…¨æ–°ç¼–è¯‘ç¬¬11ç‰ˆ(Gemini)

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSHè°ƒè¯•'
        required: false
        default: 'false'
      clean_build:
        description: 'å®Œå…¨é‡æ–°ç¼–è¯‘ (ä¼šåˆ é™¤å¹¶é‡å»ºæ‰€æœ‰ç¼“å­˜)' # æè¿°æ›´æ–°
        required: false
        default: 'false'
      config_file:
        description: 'é…ç½®æ–‡ä»¶'
        required: false
        default: 'å¢é‡ç¼“å­˜ä¼˜åŒ–.config'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE: ${{ github.event.inputs.config_file || 'å¢é‡ç¼“å­˜ä¼˜åŒ–.config' }}
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai
  CCACHE_DIR: /workdir/ccache
  TOOLCHAIN_DIR: /workdir/openwrt/staging_dir # å³ Staging Dir
  TOOLCHAIN_BUILD_DIR: /workdir/openwrt/build_dir/toolchain-x86_64_gcc-13.3.0_musl # å³ Toolchain Build Dir
  HOST_BUILD_DIR_PATH: /workdir/openwrt/build_dir/host # æ–°å¢ç¯å¢ƒå˜é‡ç”¨äº Host Build Dir
  PACKAGES_DIR: /workdir/openwrt/bin/targets
  BUILD_STATE_DIR: /workdir/build_state
  CCACHE_LOGFILE: /tmp/ccache_detailed.log
  DEBUG_LOG_FILE: /tmp/build_debug_summary.log

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - name: æ£€å‡ºä»£ç 
      uses: actions/checkout@main

    - name: ä¼˜åŒ–ç£ç›˜ç©ºé—´
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 20480
        swap-size-mb: 5120
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir'

    - name: é¢å¤–æ¸…ç†ç£ç›˜ç©ºé—´å¹¶æ£€æŸ¥
      run: |
        echo "æ¸…ç†é¢å¤–ç£ç›˜ç©ºé—´..."
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost
        sudo rm -rf /usr/share/swift /usr/local/julia* /opt/hostedtoolcache/CodeQL
        docker image prune -a -f || true
        docker system prune -af || true
        sudo apt-get clean
        sudo apt-get autoremove -y
        ROOT_AVAIL=$(df -m /dev/root | tail -1 | awk '{print $4}')
        echo "æ ¹åˆ†åŒºå¯ç”¨ç©ºé—´: ${ROOT_AVAIL}MB"
        if [ "$ROOT_AVAIL" -lt 20480 ]; then
          echo "é”™è¯¯ï¼š/dev/root å¯ç”¨ç©ºé—´ä¸è¶³ 20GB"
          exit 1
        fi
        df -h

    - name: åˆå§‹åŒ–ç¯å¢ƒ
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo -E apt-get -qq update
        sudo -E apt-get -qq install ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
        bzip2 ccache clang cmake cpio curl device-tree-compiler flex gawk gcc-multilib g++-multilib gettext \
        genisoimage git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libfuse-dev libglib2.0-dev \
        libgmp3-dev libltdl-dev libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libpython3-dev \
        libreadline-dev libssl-dev libtool llvm lrzsz msmtp ninja-build p7zip p7zip-full patch pkgconf \
        python3 python3-pyelftools python3-setuptools qemu-utils rsync scons squashfs-tools subversion \
        swig texinfo uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev
        sudo -E apt-get -qq clean
        sudo timedatectl set-timezone "$TZ"
        mkdir -p ${{ env.BUILD_STATE_DIR }} ${{ env.CCACHE_DIR }} ${{ env.HOST_BUILD_DIR_PATH }}
        chmod -R 777 /workdir
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part1.sh
        echo '# Feeds å·²é€šè¿‡ FEEDS_CONF_URL é…ç½®' >> $GITHUB_WORKSPACE/diy-part1.sh
        echo '# æ— è‡ªå®šä¹‰å†…å®¹ (diy-part1.sh)' >> $GITHUB_WORKSPACE/diy-part1.sh
        chmod +x $GITHUB_WORKSPACE/diy-part1.sh
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part2.sh
        echo 'sed -i "s/OpenWrt /OpenWrt_AutoBuild_$(date +"%Y%m%d%H%M") /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/diy-part2.sh # BanneråŠ å…¥æ—¶é—´æˆ³
        echo '# æ— é¢å¤–è‡ªå®šä¹‰å†…å®¹ (diy-part2.sh)' >> $GITHUB_WORKSPACE/diy-part2.sh
        chmod +x $GITHUB_WORKSPACE/diy-part2.sh
        if [ ! -f "$GITHUB_WORKSPACE/$CONFIG_FILE" ]; then
          echo "è­¦å‘Šï¼šé…ç½®æ–‡ä»¶ $CONFIG_FILE ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶"
          echo "# åˆ›å»ºé»˜è®¤çš„æœ€å°åŒ–é…ç½®æ–‡ä»¶" > $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64_DEVICE_generic=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_PACKAGE_luci=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
        fi
        df -h

    - name: å…‹éš†æºä»£ç å¹¶é…ç½® Feeds
      working-directory: /workdir
      run: |
        git clone --depth 1 $REPO_URL -b $REPO_BRANCH openwrt
        ln -sf /workdir/openwrt $GITHUB_WORKSPACE/openwrt
        cd openwrt
        find . -type f -name "*.sh" -exec chmod +x {} \;
        curl -L -o feeds.conf.default "$FEEDS_CONF_URL" || echo "è­¦å‘Šï¼šæ— æ³•ä¸‹è½½ feeds.conf.defaultï¼Œä½¿ç”¨ä»“åº“é»˜è®¤é…ç½®"
        cat feeds.conf.default
        rm -rf .git
        mkdir -p ${{ env.PACKAGES_DIR }} ${{ env.TOOLCHAIN_DIR }} ${{ env.TOOLCHAIN_BUILD_DIR }} ${{ env.HOST_BUILD_DIR_PATH }} ${{ env.BUILD_STATE_DIR }}
        mkdir -p logs

    # --- CACHE RESTORE STEPS ---
    - name: æ¢å¤ Staging Dir (å·²å®‰è£…å·¥å…·é“¾å’Œåº“) ç¼“å­˜
      uses: actions/cache@v3
      id: cache-staging-dir
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.TOOLCHAIN_DIR }} # /workdir/openwrt/staging_dir
        key: staging-dir-${{ env.REPO_BRANCH }}-fixed-cache

    - name: æ¢å¤ Toolchain Build Dir (äº¤å‰ç¼–è¯‘å™¨æ„å»ºäº§ç‰©) ç¼“å­˜
      uses: actions/cache@v3
      id: cache-toolchain-build-dir
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.TOOLCHAIN_BUILD_DIR }} # /workdir/openwrt/build_dir/toolchain-x86_64_gcc-13.3.0_musl
        key: toolchain-build-dir-${{ env.REPO_BRANCH }}-fixed-cache

    - name: æ¢å¤ Host Build Dir (ä¸»æœºå·¥å…·æ„å»ºäº§ç‰©) ç¼“å­˜
      uses: actions/cache@v3
      id: cache-host-build-dir
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.HOST_BUILD_DIR_PATH }} # /workdir/openwrt/build_dir/host/
        key: host-build-dir-${{ env.REPO_BRANCH }}-fixed-cache

    - name: æ¢å¤ç¼–è¯‘åŒ…ç¼“å­˜ (IPKs and Images)
      uses: actions/cache@v3
      id: cache-packages
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.PACKAGES_DIR }} # /workdir/openwrt/bin/targets
        key: packages-${{ env.REPO_BRANCH }}-fixed-cache

    - name: æ¢å¤CCACHEç¼“å­˜
      uses: actions/cache@v3
      id: cache-ccache
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-${{ env.REPO_BRANCH }}-fixed-cache

    - name: æ¢å¤æ„å»ºçŠ¶æ€ç¼“å­˜
      uses: actions/cache@v3
      id: cache-state
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-${{ env.REPO_BRANCH }}-fixed-cache
    # --- END CACHE RESTORE STEPS ---

    - name: æ£€æŸ¥ç¼“å­˜æ¢å¤çŠ¶æ€
      run: |
        echo "--- Debug Log: Cache Status ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "CONFIG_FILE: ${{ env.CONFIG_FILE }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Staging Dir ç¼“å­˜æ¢å¤çŠ¶æ€: ${{ steps.cache-staging-dir.outputs.cache-hit == 'true' && 'æˆåŠŸ' || 'æœªæ‰¾åˆ°ç¼“å­˜æˆ–ä¸ä½¿ç”¨' }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Toolchain Build Dir ç¼“å­˜æ¢å¤çŠ¶æ€: ${{ steps.cache-toolchain-build-dir.outputs.cache-hit == 'true' && 'æˆåŠŸ' || 'æœªæ‰¾åˆ°ç¼“å­˜æˆ–ä¸ä½¿ç”¨' }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Host Build Dir ç¼“å­˜æ¢å¤çŠ¶æ€: ${{ steps.cache-host-build-dir.outputs.cache-hit == 'true' && 'æˆåŠŸ' || 'æœªæ‰¾åˆ°ç¼“å­˜æˆ–ä¸ä½¿ç”¨' }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "ç¼–è¯‘åŒ…ç¼“å­˜æ¢å¤çŠ¶æ€: ${{ steps.cache-packages.outputs.cache-hit == 'true' && 'æˆåŠŸ' || 'æœªæ‰¾åˆ°ç¼“å­˜æˆ–ä¸ä½¿ç”¨' }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "CCACHEç¼“å­˜æ¢å¤çŠ¶æ€: ${{ steps.cache-ccache.outputs.cache-hit == 'true' && 'æˆåŠŸ' || 'æœªæ‰¾åˆ°ç¼“å­˜' }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "æ„å»ºçŠ¶æ€ç¼“å­˜æ¢å¤çŠ¶æ€: ${{ steps.cache-state.outputs.cache-hit == 'true' && 'æˆåŠŸ' || 'æœªæ‰¾åˆ°ç¼“å­˜æˆ–ä¸ä½¿ç”¨' }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Stagingç›®å½•å¤§å° (TOOLCHAIN_DIR): $(du -sh ${{ env.TOOLCHAIN_DIR }} 2>/dev/null || echo 'ç›®å½•ä¸å­˜åœ¨æˆ–ä¸ºç©º')" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Toolchainæ„å»ºç›®å½•å¤§å° (TOOLCHAIN_BUILD_DIR): $(du -sh ${{ env.TOOLCHAIN_BUILD_DIR }} 2>/dev/null || echo 'ç›®å½•ä¸å­˜åœ¨æˆ–ä¸ºç©º')" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Hostæ„å»ºç›®å½•å¤§å° (HOST_BUILD_DIR_PATH): $(du -sh ${{ env.HOST_BUILD_DIR_PATH }} 2>/dev/null || echo 'ç›®å½•ä¸å­˜åœ¨æˆ–ä¸ºç©º')" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "ç¼–è¯‘åŒ…ç›®å½•å¤§å° (PACKAGES_DIR): $(du -sh ${{ env.PACKAGES_DIR }} 2>/dev/null || echo 'ç›®å½•ä¸å­˜åœ¨æˆ–ä¸ºç©º')" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "CCACHEç›®å½•å¤§å° (CCACHE_DIR): $(du -sh ${{ env.CCACHE_DIR }} 2>/dev/null || echo 'ç›®å½•ä¸å­˜åœ¨æˆ–ä¸ºç©º')" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "" | tee -a ${{ env.DEBUG_LOG_FILE }}
        find ${{ env.TOOLCHAIN_DIR }}/host/bin -name "gcc*" 2>/dev/null | head -5 || echo "æœªæ‰¾åˆ°ä¸»æœºgcc" | tee -a ${{ env.DEBUG_LOG_FILE }}
        find ${{ env.TOOLCHAIN_DIR }}/toolchain-* -name "*gcc*" 2>/dev/null | head -5 || echo "æœªæ‰¾åˆ°äº¤å‰ç¼–è¯‘å™¨gcc" | tee -a ${{ env.DEBUG_LOG_FILE }}
        ls -la ${{ env.BUILD_STATE_DIR }}/ || echo "æ„å»ºçŠ¶æ€ç›®å½•ä¸ºç©º" | tee -a ${{ env.DEBUG_LOG_FILE }}
        if [ -f "${{ env.BUILD_STATE_DIR }}/config.md5" ]; then
          echo "ä¹‹å‰Config MD5: $(cat ${{ env.BUILD_STATE_DIR }}/config.md5)" | tee -a ${{ env.DEBUG_LOG_FILE }}
        fi
        if [ -f "${{ env.BUILD_STATE_DIR }}/toolchain.md5" ]; then
          echo "ä¹‹å‰Toolchain MD5: $(cat ${{ env.BUILD_STATE_DIR }}/toolchain.md5)" | tee -a ${{ env.DEBUG_LOG_FILE }}
        fi
         if [ -f "${{ env.BUILD_STATE_DIR }}/package.md5" ]; then
          echo "ä¹‹å‰Package MD5: $(cat ${{ env.BUILD_STATE_DIR }}/package.md5)" | tee -a ${{ env.DEBUG_LOG_FILE }}
        fi
        echo "--- End Debug Log: Cache Status ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        df -h

    - name: é…ç½®ç¼–è¯‘ç¯å¢ƒ
      run: |
        cd /workdir/openwrt
        if [ -f ".config" ]; then
          cp .config .config.original_from_build_dir_if_any # Save original .config if it exists from a restored build_dir
        fi
        $GITHUB_WORKSPACE/$DIY_P1_SH
        echo "æ›´æ–°å¹¶å®‰è£… Feeds..."
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        [ -e $GITHUB_WORKSPACE/files ] && cp -r $GITHUB_WORKSPACE/files ./files
        cp $GITHUB_WORKSPACE/$CONFIG_FILE ./.config
        cp .config .config.input # ä¿å­˜ä¸€ä»½è¾“å…¥é…ç½®ç”¨äºæ¯”è¾ƒ
        $GITHUB_WORKSPACE/$DIY_P2_SH
        echo "CONFIG_AUTOREMOVE=n" >> .config # Ensure these are not enabled by default
        echo "CONFIG_AUTOREBUILD=n" >> .config # Ensure these are not enabled by default
        echo "ç¡®ä¿åŒ…å«å¿…è¦çš„å›ºä»¶ç”Ÿæˆé…ç½®..."
        if ! grep -q "CONFIG_TARGET_ROOTFS_SQUASHFS=y" .config; then echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config; fi
        if ! grep -q "CONFIG_TARGET_IMAGES_GZIP=y" .config; then echo "CONFIG_TARGET_IMAGES_GZIP=y" >> .config; fi
        if ! grep -q "CONFIG_TARGET_ROOTFS_TARGZ=y" .config; then echo "CONFIG_TARGET_ROOTFS_TARGZ=y" >> .config; fi
        if grep -q "CONFIG_TARGET_x86=y" .config; then
          if ! grep -q "CONFIG_GRUB_IMAGES=y" .config; then echo "CONFIG_GRUB_IMAGES=y" >> .config; fi
          if ! grep -q "CONFIG_TARGET_IMAGES_PAD=y" .config; then echo "CONFIG_TARGET_IMAGES_PAD=y" >> .config; fi
        fi
        make defconfig
        grep "^CONFIG_PACKAGE_.*=y" .config.input | sort > packages_input.txt || true
        grep "^CONFIG_PACKAGE_.*=y" .config | sort > packages_defconfig.txt || true
        comm -23 packages_input.txt packages_defconfig.txt > missing_packages.txt
        if [ -s missing_packages.txt ]; then
          echo "è­¦å‘Šï¼šä»¥ä¸‹åŒ…åœ¨ defconfig åç¼ºå¤±ï¼Œå°†å°è¯•æ¢å¤ï¼š" | tee -a ${{ env.DEBUG_LOG_FILE }}
          cat missing_packages.txt | tee -a ${{ env.DEBUG_LOG_FILE }}
          cat missing_packages.txt >> .config
          while read -r line; do
            pkg=$(echo "$line" | sed 's/CONFIG_PACKAGE_\(.*\)=y/\1/')
            echo "å°è¯•é‡æ–°å®‰è£…ç¼ºå¤±åŒ…: $pkg (é€šå¸¸è¿™æ„å‘³ç€å®ƒæˆ–å…¶ä¾èµ–æœªè¢«defconfigé€‰ä¸­)" | tee -a ${{ env.DEBUG_LOG_FILE }}
            # Re-running feeds install for individual packages here can be slow and might not always be the right fix
            # ./scripts/feeds install "$pkg" || echo "è­¦å‘Šï¼šæ— æ³•å®‰è£… $pkgï¼Œå¯èƒ½ä¸åœ¨ feeds ä¸­"
          done < missing_packages.txt
          echo "é‡æ–°æ‰§è¡Œ make defconfig ä»¥ç¡®ä¿ä¾èµ–ä¸€è‡´æ€§" | tee -a ${{ env.DEBUG_LOG_FILE }}
          make defconfig
        else
          echo "æ‰€æœ‰åœ¨è¾“å…¥ .config ä¸­æŒ‡å®šçš„ CONFIG_PACKAGE_*=y é…ç½®é¡¹åœ¨ defconfig åå‡ä¿ç•™æˆ–è¢«æ­£ç¡®å¤„ç†ï¼Œæ— ç¼ºå¤±ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
        fi
        echo "æœ€ç»ˆé…ç½®ä¸­çš„é•œåƒç”Ÿæˆé€‰é¡¹:" | tee -a ${{ env.DEBUG_LOG_FILE }}
        grep -E "CONFIG_TARGET_ROOTFS|CONFIG_TARGET_IMAGES|CONFIG_GRUB|CONFIG_ISO|CONFIG_EFI" .config | tee -a ${{ env.DEBUG_LOG_FILE }} || echo "æœªæ‰¾åˆ°é•œåƒç›¸å…³é…ç½®" | tee -a ${{ env.DEBUG_LOG_FILE }}
        diff .config.input .config > config_diff.txt || echo "é…ç½®æ— å·®å¼‚"
        echo "--- Debug Log: Config diff after defconfig and recovery ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        cat config_diff.txt | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "--- End Debug Log: Config diff ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        df -h

    - name: æ£€æŸ¥æºç å˜åŒ– (Feeds Makefile Hashes)
      id: check-feeds
      run: |
        cd /workdir/openwrt
        mkdir -p ${{ env.BUILD_STATE_DIR }}
        find feeds -type f -name "Makefile" -exec sha256sum {} \; | sort | sha256sum > ${{ env.BUILD_STATE_DIR }}/feeds.sha256
        CURRENT_FEEDS_HASH=$(cat ${{ env.BUILD_STATE_DIR }}/feeds.sha256 | awk '{print $1}')
        PREVIOUS_FEEDS_HASH=$(cat ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256 2>/dev/null | awk '{print $1}' || echo "")
        echo "--- Debug Log: Feeds Change Check ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "å½“å‰ feeds å“ˆå¸Œ: $CURRENT_FEEDS_HASH" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "ä¹‹å‰ feeds å“ˆå¸Œ: $PREVIOUS_FEEDS_HASH" | tee -a ${{ env.DEBUG_LOG_FILE }}
        if [ "$CURRENT_FEEDS_HASH" != "$PREVIOUS_FEEDS_HASH" ]; then
          echo "feeds_changed=true" >> $GITHUB_ENV
          echo "Feeds çš„ Makefile ç»“æ„å·²å˜æ›´ï¼Œå¯èƒ½éœ€è¦é‡æ–°ç¼–è¯‘ç›¸å…³è½¯ä»¶åŒ…ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
        else
          echo "feeds_changed=false" >> $GITHUB_ENV
          echo "Feeds çš„ Makefile ç»“æ„æœªå˜æ›´ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
        fi
        echo "--- End Debug Log: Feeds Change Check ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        # Always copy current to previous for next run, regardless of change,
        # because BUILD_STATE_DIR cache key might be different if other things changed.
        cp ${{ env.BUILD_STATE_DIR }}/feeds.sha256 ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256

    - name: å¼€å¯SSHè°ƒè¯• (å¦‚æœéœ€è¦)
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    - name: ä¸‹è½½è½¯ä»¶åŒ… (make download)
      run: |
        cd /workdir/openwrt
        MAX_RETRIES=3
        RETRY_WAIT=10
        cat > download_with_retry.sh << 'EOF'
        #!/bin/bash
        set -e; MAX_RETRIES=$1; RETRY_WAIT=$2; shift 2; retries=0
        until [ $retries -ge $MAX_RETRIES ]; do
          echo "å°è¯•ä¸‹è½½ï¼Œç¬¬ $((retries+1)) æ¬¡ï¼Œå…± $MAX_RETRIES æ¬¡...";
          if make download -j$(nproc) "$@" 2>&1 | tee "logs/download_attempt_$(date +%s)_$retries.log"; then echo "ä¸‹è½½æˆåŠŸï¼"; exit 0; fi
          retries=$((retries+1));
          if [ $retries -lt $MAX_RETRIES ]; then echo "ä¸‹è½½å¤±è´¥ï¼Œç­‰å¾… $RETRY_WAIT ç§’åé‡è¯•..."; sleep $RETRY_WAIT; fi
        done
        echo "è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œä¿å­˜æ—¥å¿—ä»¥åˆ†æå¤±è´¥çš„åŒ…...";
        # Attempt to find the last attempt log, or just use the last numbered one.
        LAST_LOG=$(ls -t logs/download_attempt_*.log 2>/dev/null | head -n 1)
        if [ -n "$LAST_LOG" ]; then
          cp "$LAST_LOG" logs/download_failures.log;
        else
          echo "æ— æ³•æ‰¾åˆ°ä¸‹è½½å°è¯•æ—¥å¿—ã€‚" > logs/download_failures.log
        fi
        exit 1
        EOF
        chmod +x download_with_retry.sh
        # First, try with retry script. If it fails, try one last time with V=s for more detailed logs.
        if ! ./download_with_retry.sh $MAX_RETRIES $RETRY_WAIT; then
            echo "ä¸‹è½½é‡è¯•å¤±è´¥ï¼Œå°è¯•å•çº¿ç¨‹è¯¦ç»†æ—¥å¿—ä¸‹è½½..." | tee -a ${{ env.DEBUG_LOG_FILE }}
            make download -j1 V=s 2>&1 | tee logs/download_final_attempt.log || true # Allow to proceed even if this fails
        fi

        # Configure ccache after downloads, before compile
        mkdir -p ${{ env.CCACHE_DIR }}
        ccache -o cache_dir=${{ env.CCACHE_DIR }}
        ccache -o max_size=8G # Set ccache size
        ccache -z # Zero ccache stats before compilation for accurate run stats
        echo "CCACHE é…ç½®å®Œæˆå¹¶å·²æ¸…é›¶ç»Ÿè®¡æ•°æ®ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
        df -h

    - name: æ£€æµ‹å¹¶å¤„ç†ä¸‹è½½å¤±è´¥çš„åŒ… (å¦‚æœéœ€è¦)
      run: |
        cd /workdir/openwrt
        # (detect_failed_downloads.sh script from previous version can be used here)
        # For brevity, assuming the script exists or is inlined
        if [ -f "logs/download_failures.log" ] || [ -f "logs/download_final_attempt.log" ]; then
            COMBINED_DOWNLOAD_LOG="logs/combined_download_errors.log"
            cat logs/download_failures.log logs/download_final_attempt.log 2>/dev/null > "$COMBINED_DOWNLOAD_LOG"

            echo "åˆ†æä¸‹è½½å¤±è´¥æ—¥å¿— ($COMBINED_DOWNLOAD_LOG)..." | tee -a ${{ env.DEBUG_LOG_FILE }};
            # Simplified grep for typical download error messages
            grep -E "(curl:.*(Couldn't resolve host|Connection timed out|403 Forbidden|404 Not Found)|No more mirrors to try|Download failed)" "$COMBINED_DOWNLOAD_LOG" > failed_urls.txt || true;
            
            declare -A failed_packages_map;
            while IFS= read -r line; do
                # Try to extract package name from URL (very basic, might need refinement)
                if [[ $line =~ \/([^\/_]+([_-][0-9a-zA-Z\.]+)?)\.(tar\.|zip|gz|xz|bz2) ]]; then
                    pkg_name_from_url="${BASH_REMATCH[1]}"
                    # Further clean up common versioning patterns if BASH_REMATCH[2] exists
                    pkg_name_from_url_base=$(echo "$pkg_name_from_url" | sed -E 's/[-_][0-9]+.*//; s/-git//')
                    if [ -n "$pkg_name_from_url_base" ]; then
                         failed_packages_map["$pkg_name_from_url_base"]=1;
                         echo "æ£€æµ‹åˆ°å¯èƒ½ä¸‹è½½å¤±è´¥çš„åŒ… (åŸºäºURL): $pkg_name_from_url_base" | tee -a ${{ env.DEBUG_LOG_FILE }};
                    fi
                fi
            done < failed_urls.txt;

            if [ ${#failed_packages_map[@]} -gt 0 ]; then
                echo "ä»¥ä¸‹åŒ…æˆ–å…¶æºç å¯èƒ½ä¸‹è½½å¤±è´¥ï¼Œå°†å°è¯•ä» .config ä¸­ç¦ç”¨ï¼š" | tee -a ${{ env.DEBUG_LOG_FILE }};
                PACKAGES_MODIFIED=0
                for pkg_base in "${!failed_packages_map[@]}"; do
                    echo " - ç–‘ä¼¼é—®é¢˜åŒ…: $pkg_base" | tee -a ${{ env.DEBUG_LOG_FILE }};
                    # Grep for the base package name in CONFIG_PACKAGE lines
                    # This is a broad match, specific package might need more precise regex
                    if grep -q "CONFIG_PACKAGE_.*${pkg_base}.*=y" .config; then
                        echo "  åœ¨ .config ä¸­æ‰¾åˆ°ç›¸å…³åŒ…ï¼Œå°è¯•ç¦ç”¨..." | tee -a ${{ env.DEBUG_LOG_FILE }}
                        sed -i -E "/CONFIG_PACKAGE_.*${pkg_base}.*=y/s/=y$/=n/g" .config # Change =y to =n
                        # Also comment out related non-package CONFIG lines if necessary (more complex)
                        PACKAGES_MODIFIED=1
                    fi
                done;
                if [ $PACKAGES_MODIFIED -eq 1 ]; then
                    echo "ç”±äºæ£€æµ‹åˆ°ä¸‹è½½å¤±è´¥ï¼Œå·²ä¿®æ”¹ .config æ–‡ä»¶ï¼Œé‡æ–°è¿è¡Œ make defconfig" | tee -a ${{ env.DEBUG_LOG_FILE }}
                    make defconfig;
                else
                    echo "æœªåœ¨ .config ä¸­æ‰¾åˆ°æ˜ç¡®åŒ¹é…çš„å·²å¯ç”¨åŒ…è¿›è¡Œç¦ç”¨ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
                fi
            else
                echo "æœªä»ä¸‹è½½æ—¥å¿—ä¸­æ˜ç¡®è¯†åˆ«å‡ºç‰¹å®šä¸‹è½½å¤±è´¥çš„åŒ…åã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
            fi
        else
            echo "æ²¡æœ‰æ‰¾åˆ°ä¸‹è½½å¤±è´¥çš„æ—¥å¿—æ–‡ä»¶ (logs/download_failures.log æˆ– logs/download_final_attempt.log)ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
        fi
        echo "ä¸‹è½½å¤±è´¥åŒ…æ£€æµ‹å¤„ç†å®Œæˆã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}


    - name: æ™ºèƒ½ç¼–è¯‘å›ºä»¶
      id: compile
      run: |
        echo "--- Debug Log: Compile Step Start ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        cd /workdir/openwrt
        export CCACHE_DIR=${{ env.CCACHE_DIR }}
        export PATH="/usr/lib/ccache:$PATH" # Ensure ccache is in PATH
        export CCACHE_LOGFILE=${{ env.CCACHE_LOGFILE }}
        echo "CCACHE_LOGFILE in compile step set to: $CCACHE_LOGFILE" | tee -a ${{ env.DEBUG_LOG_FILE }}

        cleanup_temp_files() {
          echo "æ¸…ç†ä¸´æ—¶æ–‡ä»¶ä»¥é‡Šæ”¾ç©ºé—´..."; find /tmp -maxdepth 1 -type f -delete || true; df -h | tee -a ${{ env.DEBUG_LOG_FILE }};
        }

        save_md5_info() {
          echo "ä¿å­˜é…ç½®MD5ä¿¡æ¯..." | tee -a ${{ env.DEBUG_LOG_FILE }}
          mkdir -p ${{ env.BUILD_STATE_DIR }};
          cp .config ${{ env.BUILD_STATE_DIR }}/config.txt; # Save the actual .config used for the build
          echo "$TOOLCHAIN_MD5" > ${{ env.BUILD_STATE_DIR }}/toolchain.md5;
          echo "$PACKAGE_MD5" > ${{ env.BUILD_STATE_DIR }}/package.md5;
          echo "æ„å»ºçŠ¶æ€MD5ä¿¡æ¯ä¿å­˜å®Œæˆã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
        }
        
        handle_compile_error() {
          local compile_log_content="$1"
          echo "æ£€æµ‹åˆ°ç¼–è¯‘å¤±è´¥ï¼Œå°è¯•è¯†åˆ«ä¸‹è½½é—®é¢˜..." | tee -a ${{ env.DEBUG_LOG_FILE }}
          mkdir -p logs;
          # Use a more specific error log name if not already done
          # echo "$compile_log_content" > "logs/compile_error_$(date +%s).log" 

          # Basic check for download-related errors in compile output
          # This is a fallback if make download didn't catch everything or if a package's internal script downloads
          if echo "$compile_log_content" | grep -q -E "(No more mirrors to try|Download failed|Couldn't resolve host|404 Not Found|403 Forbidden)"; then
            # Try to identify the failing package (this is tricky from generic make output)
            # A common pattern is "make[3]: Leaving directory '/workdir/openwrt/build_dir/.../package-name-version'" just before error
            # Or "Applying ./patches/..." or "Configuring package-name..."
            local failing_pkg_context
            failing_pkg_context=$(echo "$compile_log_content" | grep -B 10 -E "(No more mirrors to try|Download failed)" | grep -o -E "package/[^[:space:]/]+/[^[:space:]/]+" | tail -n 1 | awk -F'/' '{print $NF}')
            
            if [ -n "$failing_pkg_context" ]; then
                echo "ç¼–è¯‘é”™è¯¯ä¸­æ£€æµ‹åˆ°ä¸åŒ… '$failing_pkg_context' ç›¸å…³çš„ä¸‹è½½é—®é¢˜ã€‚å»ºè®®æ£€æŸ¥è¯¥åŒ…çš„Makefileæˆ–æºç ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
                # For now, we don't automatically disable here as it's harder to pinpoint from compile log
                # User might need to manually intervene or improve the package's Makefile
            else
                echo "ç¼–è¯‘é”™è¯¯ä¸­æ£€æµ‹åˆ°ä¸‹è½½é—®é¢˜ï¼Œä½†æœªèƒ½è‡ªåŠ¨è¯†åˆ«å…·ä½“åŒ…ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
            fi
            # No automatic recompile attempt here, to avoid loops if it's not a simple download issue
            return 1 # Indicate error still stands
          fi
          return 1 # Default to error still stands if not a clear download issue from compile log
        }

        compile_firmware() {
          echo ">>> CCACHE: Zeroing statistics at start of compile_firmware function." | tee -a ${{ env.DEBUG_LOG_FILE }}
          ccache -z
          echo ">>> CCACHE: Statistics at START of compile_firmware function (after zeroing):" | tee -a ${{ env.DEBUG_LOG_FILE }}
          ccache -s | tee -a ${{ env.DEBUG_LOG_FILE }}

          MAIN_MAKE_CMD="make -j$(nproc) V=s"
          FALLBACK_MAKE_CMD="make -j1 V=s" # For retries on error
          
          # Determine build strategy
          if [ $DO_FULL_BUILD -eq 1 ]; then
            echo "--- Compile Branch: Full Build ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
            # For a full build, ensure tools and toolchain are compiled first if not present from cache
            if [ ! -d "${{ env.TOOLCHAIN_DIR }}/toolchain-"* ] || [ ! -d "${{ env.HOST_BUILD_DIR_PATH }}/stamp" ]; then # Basic check
              echo "ç¼–è¯‘ä¸»æœºå·¥å…·å’Œå·¥å…·é“¾..." | tee -a ${{ env.DEBUG_LOG_FILE }}
              make tools/compile ${FALLBACK_MAKE_CMD} || make tools/compile ${FALLBACK_MAKE_CMD} # Retry on failure
              make toolchain/compile ${FALLBACK_MAKE_CMD} || make toolchain/compile ${FALLBACK_MAKE_CMD} # Retry on failure
            else
              echo "ä¸»æœºå·¥å…·å’Œå·¥å…·é“¾ä¼¼ä¹å·²å­˜åœ¨ (æ¥è‡ªç¼“å­˜æˆ–ä¹‹å‰æ­¥éª¤)ï¼Œè·³è¿‡æ˜¾å¼ç¼–è¯‘ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
            fi
            cleanup_temp_files
            echo "ç¼–è¯‘å®Œæ•´å›ºä»¶ (World)..." | tee -a ${{ env.DEBUG_LOG_FILE }}
            if ! $MAIN_MAKE_CMD 2>&1 | tee logs/compile_output.log; then
              if ! handle_compile_error "$(cat logs/compile_output.log)"; then # If not a resolvable download error
                 $FALLBACK_MAKE_CMD # Final attempt with single thread
              fi
            fi
          elif [ $DO_PACKAGE_BUILD -eq 1 ] || [ "${{ env.feeds_changed }}" = "true" ]; then
            echo "--- Compile Branch: Package Build or Feeds Changed ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
            echo "è½¯ä»¶åŒ…é…ç½®å˜åŒ–æˆ–Feedsæºç æ›´æ–°ï¼Œæ‰§è¡Œè½¯ä»¶åŒ…ç¼–è¯‘..." | tee -a ${{ env.DEBUG_LOG_FILE }}
            echo ">>> WARNING: Running 'make package/clean' due to package/feeds changes. This cleans all previously compiled packages." | tee -a ${{ env.DEBUG_LOG_FILE }}
            make package/clean V=s || true # Clean previous package builds
            if ! make package/compile $MAIN_MAKE_CMD 2>&1 | tee logs/compile_output.log; then
               if ! handle_compile_error "$(cat logs/compile_output.log)"; then
                 make package/compile $FALLBACK_MAKE_CMD
               fi
            fi
            make package/index V=s || make package/index $FALLBACK_MAKE_CMD
          else
            echo "--- Compile Branch: Minimal Incremental Build ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
            echo "é…ç½®å’ŒFeedså‡æœªæ˜¾è‘—å˜åŒ–ï¼Œæ‰§è¡Œæœ€å°åŒ–å¢é‡ç¼–è¯‘ (World)..." | tee -a ${{ env.DEBUG_LOG_FILE }}
            if ! $MAIN_MAKE_CMD 2>&1 | tee logs/compile_output.log; then
              if ! handle_compile_error "$(cat logs/compile_output.log)"; then
                 $FALLBACK_MAKE_CMD
              fi
            fi
          fi
          
          echo "ç¡®ä¿æ‰§è¡Œæœ€ç»ˆçš„å›ºä»¶ç”Ÿæˆæ­¥éª¤ (target/install)..." | tee -a ${{ env.DEBUG_LOG_FILE }}
          make target/install $FALLBACK_MAKE_CMD # Use fallback for safety and detailed logs if issues
          
          save_md5_info # Save MD5s of the .config that was used for this build attempt

          echo "æ£€æŸ¥å›ºä»¶ç”Ÿæˆç»“æœ:" | tee -a ${{ env.DEBUG_LOG_FILE }}
          find bin/targets -type f \( -name "*.bin" -o -name "*combined*" -o -name "*sysupgrade*" -o -name "*.img.gz" \) -print0 | xargs -0 ls -lh || echo "æ²¡æœ‰æ‰¾åˆ°ä¸»è¦å›ºä»¶æ–‡ä»¶ï¼" | tee -a ${{ env.DEBUG_LOG_FILE }}
          
          if [ -z "$(find bin/targets -type f \( -name "*.bin" -o -name "*combined*" -o -name "*sysupgrade*" -o -name "*.img.gz" \) -print -quit)" ]; then
            echo "è­¦å‘Šï¼šä¸»è¦å›ºä»¶æ–‡ä»¶æœªæ‰¾åˆ°ã€‚æ£€æŸ¥ logs/compile_output.log è·å–è¯¦æƒ…ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
          fi

          echo ">>> CCACHE: Statistics at END of compile_firmware function:" | tee -a ${{ env.DEBUG_LOG_FILE }}
          ccache -s | tee -a ${{ env.DEBUG_LOG_FILE }}

          # Check the exit status of the last critical make command (target/install)
          # This is a simplification; more robust error checking might be needed throughout.
          if [ $? -eq 0 ] && [ -n "$(find bin/targets -type f \( -name "*.bin" -o -name "*combined*" -o -name "*sysupgrade*" -o -name "*.img.gz" \) -print -quit)" ]; then
            echo "compile_firmwareå‡½æ•°åˆ¤æ–­ä¸ºæˆåŠŸ (å›ºä»¶å·²ç”Ÿæˆ)ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
            return 0
          else
            echo "compile_firmwareå‡½æ•°åˆ¤æ–­ä¸ºå¤±è´¥ (å›ºä»¶æœªç”Ÿæˆæˆ–makeå‡ºé”™)ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
            return 1
          fi
        }
        
        # --- Build decision logic (based on MD5s and feeds_changed) ---
        TOOLCHAIN_CONFIG_SUBSET=$(grep -E "^CONFIG_TARGET|^CONFIG_ARCH|^CONFIG_TOOLCHAIN" .config | grep -v "NOT_SET" | sort)
        TOOLCHAIN_MD5=$(echo "$TOOLCHAIN_CONFIG_SUBSET" | md5sum | awk '{print $1}')
        PREVIOUS_TOOLCHAIN_MD5=$(cat ${{ env.BUILD_STATE_DIR }}/toolchain.md5 2>/dev/null || echo "not_found")

        PACKAGE_CONFIG_SUBSET=$(grep "^CONFIG_PACKAGE_" .config | grep "=y" | sort) # Only consider selected packages
        PACKAGE_MD5=$(echo "$PACKAGE_CONFIG_SUBSET" | md5sum | awk '{print $1}')
        PREVIOUS_PACKAGE_MD5=$(cat ${{ env.BUILD_STATE_DIR }}/package.md5 2>/dev/null || echo "not_found")
        
        DO_FULL_BUILD=0
        DO_PACKAGE_BUILD=0

        echo "--- Debug Log: Build Decision Variables ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Input clean_build: ${{ github.event.inputs.clean_build }}" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Current TOOLCHAIN_MD5 (from .config subset): $TOOLCHAIN_MD5" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Previous TOOLCHAIN_MD5 (from cache): $PREVIOUS_TOOLCHAIN_MD5" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Current PACKAGE_MD5 (from .config subset): $PACKAGE_MD5" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Previous PACKAGE_MD5 (from cache): $PREVIOUS_PACKAGE_MD5" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "env.feeds_changed: ${{ env.feeds_changed }}" | tee -a ${{ env.DEBUG_LOG_FILE }}

        if [ "${{ github.event.inputs.clean_build }}" = "true" ]; then
          echo "clean_build is true, setting DO_FULL_BUILD=1" | tee -a ${{ env.DEBUG_LOG_FILE }}
          DO_FULL_BUILD=1
        elif [ "$PREVIOUS_TOOLCHAIN_MD5" = "not_found" ] || [ "$TOOLCHAIN_MD5" != "$PREVIOUS_TOOLCHAIN_MD5" ]; then
          echo "Toolchain config changed or first build with this state, setting DO_FULL_BUILD=1" | tee -a ${{ env.DEBUG_LOG_FILE }}
          DO_FULL_BUILD=1
        elif [ "$PREVIOUS_PACKAGE_MD5" = "not_found" ] || [ "$PACKAGE_MD5" != "$PREVIOUS_PACKAGE_MD5" ]; then
          echo "Package config changed, setting DO_PACKAGE_BUILD=1" | tee -a ${{ env.DEBUG_LOG_FILE }}
          DO_PACKAGE_BUILD=1
        elif [ "${{ env.feeds_changed }}" = "true" ]; then # Check feeds change only if configs seem same
           echo "Feeds changed (and configs appear same), setting DO_PACKAGE_BUILD=1" | tee -a ${{ env.DEBUG_LOG_FILE }}
           DO_PACKAGE_BUILD=1
        fi
        echo "Final DO_FULL_BUILD: $DO_FULL_BUILD" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "Final DO_PACKAGE_BUILD: $DO_PACKAGE_BUILD" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "--- End Debug Log: Build Decision Variables ---" | tee -a ${{ env.DEBUG_LOG_FILE }}

        # Call the main compile function
        if compile_firmware; then
          echo "DEVICE_NAME=_$(grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' | tr '\n' '_' | sed 's/_$//')" >> $GITHUB_ENV
          echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          # Consider exiting with error if compile_firmware fails, to make job fail
          # exit 1 
        fi
        
        echo "Final ccache stats for the entire compile step:" | tee -a ${{ env.DEBUG_LOG_FILE }}
        ccache -s | tee -a ${{ env.DEBUG_LOG_FILE }}
        df -h | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "--- Debug Log: Compile Step End ---" | tee -a ${{ env.DEBUG_LOG_FILE }}


    # MODIFIED STEP for checking sizes (replaces old 'å¤‡ä»½ç¼“å­˜å‰æ£€æŸ¥å·¥å…·é“¾å¤§å°')
    - name: å¤‡ä»½ç¼“å­˜å‰æ£€æŸ¥å·¥å…·é“¾å’Œå„æ„å»ºç›®å½•å¤§å°
      if: "!cancelled()" # Always run if not cancelled to see sizes even on failure
      run: |
        echo "ç¼–è¯‘å®Œæˆæˆ–ä¸­æ­¢ï¼Œè¯¦ç»†æ£€æŸ¥å·¥å…·é“¾å’Œå„æ„å»ºç¼“å­˜ç›®å½•å¤§å°..." | tee -a ${{ env.DEBUG_LOG_FILE }}
        
        CURRENT_DATE_WITH_TZ=$(date +"%Y-%m-%d %H:%M:%S %Z")
        echo "" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "--- è¯¦ç»†ç›®å½•å¤§å°æ£€æŸ¥ (du -sh) ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "æ£€æŸ¥æ—¶é—´: $CURRENT_DATE_WITH_TZ" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "--------------------------------------------------" | tee -a ${{ env.DEBUG_LOG_FILE }}
        
        check_and_log_size() {
            local dir_path="$1"
            local dir_desc="$2"
            local size_output
            local readable_size="æœªçŸ¥æˆ–ç›®å½•ä¸å­˜åœ¨"

            if [ -e "${dir_path}" ]; then 
                readable_size=$(du -sh "${dir_path}" 2>/dev/null | awk '{print $1}')
                if [ -z "${readable_size}" ]; then readable_size="è·å–å¤±è´¥æˆ–ä¸ºç©º"; fi
                echo "$dir_desc (${dir_path}): ${readable_size}"
                echo "[SIZE_CHECK] $dir_desc (${dir_path}): ${readable_size}" >> ${{ env.DEBUG_LOG_FILE }}
            else
                echo "$dir_desc (${dir_path}): ç›®å½•ä¸å­˜åœ¨"
                echo "[SIZE_CHECK] $dir_desc (${dir_path}): ç›®å½•ä¸å­˜åœ¨" >> ${{ env.DEBUG_LOG_FILE }}
            fi
        }

        check_and_log_size "${{ env.TOOLCHAIN_DIR }}" "1. å·¥å…·é“¾å®‰è£…ç›®å½• (Staging Dir)"
        check_and_log_size "${{ env.TOOLCHAIN_BUILD_DIR }}" "2. å·¥å…·é“¾æ„å»ºç›®å½• (Toolchain Build Dir)"
        check_and_log_size "${{ env.HOST_BUILD_DIR_PATH }}" "3. ä¸»æœºå·¥å…·æ„å»ºç›®å½• (Host Build Dir)"
        check_and_log_size "${{ env.PACKAGES_DIR }}" "4. ç¼–è¯‘åŒ…è¾“å‡ºç›®å½• (IPKs/Images)"
        check_and_log_size "${{ env.CCACHE_DIR }}" "5. CCACHEç›®å½•"
        check_and_log_size "/workdir/openwrt/build_dir/" "6. æ•´ä¸ª OpenWrt build_dir ç›®å½• (å‚è€ƒ)"
        check_and_log_size "${{ env.BUILD_STATE_DIR }}" "7. æ„å»ºçŠ¶æ€ç›®å½• (Build State)"
        
        echo "--------------------------------------------------" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "--- è¯¦ç»†ç›®å½•å¤§å°æ£€æŸ¥ç»“æŸ ---" | tee -a ${{ env.DEBUG_LOG_FILE }}
        echo "" | tee -a ${{ env.DEBUG_LOG_FILE }}

        mkdir -p ${{ env.BUILD_STATE_DIR }}
        echo "ç¼“å­˜å…ƒæ•°æ®åˆ›å»º/æ£€æŸ¥æ—¶é—´: $CURRENT_DATE_WITH_TZ" > ${{ env.BUILD_STATE_DIR }}/cache_metadata_timestamp.txt
        echo "è¿è¡ŒID: ${{ github.run_id }}" >> ${{ env.BUILD_STATE_DIR }}/cache_metadata_timestamp.txt
        echo "æ„å»ºåˆ†æ”¯: ${{ env.REPO_BRANCH }}" >> ${{ env.BUILD_STATE_DIR }}/cache_metadata_timestamp.txt
        echo "[DEBUG_LOG] å·²æ›´æ–°ç¼“å­˜å…ƒæ•°æ®æ—¶é—´æˆ³æ–‡ä»¶: ${{ env.BUILD_STATE_DIR }}/cache_metadata_timestamp.txt" >> ${{ env.DEBUG_LOG_FILE }}
        echo "å·²æ›´æ–°ç¼“å­˜å…ƒæ•°æ®æ—¶é—´æˆ³æ–‡ä»¶: ${{ env.BUILD_STATE_DIR }}/cache_metadata_timestamp.txt"


    # --- CACHE SAVE STEPS (Implicit via post-job execution of restore steps) ---
    # The 'actions/cache@v3' steps defined earlier for restore will automatically handle saving
    # in the post-job execution if their keys don't have an exact match from a previous run.
    # No explicit 'save' steps are needed here unless using actions/cache/save explicitly.

    - name: éªŒè¯ç¼“å­˜å·²æ­£ç¡®é…ç½®å¾…ä¿å­˜
      if: "!cancelled()"
      run: |
        echo "å·²å®Œæˆç¼–è¯‘å’Œå¤§å°æ£€æŸ¥ã€‚ç¼“å­˜å°†åœ¨ä½œä¸šç»“æŸæ—¶æ ¹æ®å®šä¹‰çš„keyå’Œpathè‡ªåŠ¨ä¿å­˜ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
        if [ -f "${{ env.BUILD_STATE_DIR }}/cache_metadata_timestamp.txt" ]; then
          echo "ç¼“å­˜å…ƒæ•°æ®æ—¶é—´æˆ³å†…å®¹:" | tee -a ${{ env.DEBUG_LOG_FILE }}
          cat ${{ env.BUILD_STATE_DIR }}/cache_metadata_timestamp.txt | tee -a ${{ env.DEBUG_LOG_FILE }}
        fi
        df -h | tee -a ${{ env.DEBUG_LOG_FILE }}

    - name: Upload Debug Logs
      if: always()
      uses: actions/upload-artifact@main
      with:
        name: build-debug-logs-${{ github.run_id }}
        path: |
          ${{ env.DEBUG_LOG_FILE }}
          ${{ env.CCACHE_LOGFILE }}
          /workdir/openwrt/logs/ # Upload make output logs
          /workdir/openwrt/config_diff.txt # Upload config diff
          /workdir/openwrt/.config # Upload final .config used
          /workdir/openwrt/.config.input # Upload .config as copied from input
        retention-days: 7

    - name: æ•´ç†æ–‡ä»¶
      id: organize
      if: steps.compile.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true' && !cancelled()
      run: |
        echo "æœç´¢æ‰€æœ‰å¯èƒ½çš„å›ºä»¶æ–‡ä»¶..."
        find /workdir/openwrt/bin -type f \( -name "*.bin" -o -name "*.img" -o -name "*.img.gz" -o -name "*sysupgrade*" -o -name "*combined*" \) -exec ls -lh {} + || echo "æœªæ‰¾åˆ°å¯èƒ½çš„å›ºä»¶æ–‡ä»¶"
        
        FIRMWARE_DIR_PATH_SET="" # Shell variable to track if firmware dir is set

        if [ ! -d "/workdir/openwrt/bin/targets" ]; then
          echo "é”™è¯¯ï¼šç¼–è¯‘ç›®æ ‡ç›®å½• /workdir/openwrt/bin/targets ä¸å­˜åœ¨ï¼Œå¯èƒ½ç¼–è¯‘å¤±è´¥æˆ–æœªç”Ÿæˆä»»ä½•å›ºä»¶ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
          # Create a dummy path to prevent downstream errors if UPLOAD_FIRMWARE is true
          mkdir -p /workdir/openwrt/bin/targets/unknown/empty_firmware 
          echo "FIRMWARE=/workdir/openwrt/bin/targets/unknown/empty_firmware" >> $GITHUB_ENV 
          echo "status=success" >> $GITHUB_OUTPUT # Still output success for organize step if no firmware but compile was 'success'
          exit 0
        fi

        TARGET_SUBDIRS=$(find /workdir/openwrt/bin/targets -mindepth 1 -maxdepth 2 -type d -not -name "packages" -print)
        if [ -z "$TARGET_SUBDIRS" ]; then
          echo "è­¦å‘Šï¼šåœ¨ /workdir/openwrt/bin/targets ä¸‹æœªæ‰¾åˆ°å…·ä½“çš„ç›®æ ‡å­ç›®å½• (å¦‚ x86/64)ã€‚å°†å°è¯•åœ¨é¡¶å±‚æœç´¢ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
          TARGET_SUBDIRS="/workdir/openwrt/bin/targets" # Fallback to searching in bin/targets itself
        fi

        for TARGET_PATH_ITEM in $TARGET_SUBDIRS; do
          CANDIDATE_FIRMWARE_DIR="$TARGET_PATH_ITEM/firmware" # Define firmware dir consistently
          echo "å¤„ç†ç›®æ ‡è·¯å¾„: $TARGET_PATH_ITEM" | tee -a ${{ env.DEBUG_LOG_FILE }}
          # Ensure firmware output directory exists
          mkdir -p "$CANDIDATE_FIRMWARE_DIR"
          
          FILES_COPIED_COUNT=0
          # Prefer specific patterns first
          for pattern in "*combined.img.gz" "*sysupgrade.img.gz" "*sysupgrade.bin" "*.img.gz" "*.bin"; do
            # Find files in current TARGET_PATH_ITEM, not recursively from /workdir/openwrt/bin
            # and ensure they are not in a 'packages' subdirectory at this level
            find "$TARGET_PATH_ITEM" -maxdepth 1 -type f -name "$pattern" ! -path "*/packages/*" -exec cp -v -f {} "$CANDIDATE_FIRMWARE_DIR/" \; -print | while read -r file_copied; do
              if [ -n "$file_copied" ]; then FILES_COPIED_COUNT=$((FILES_COPIED_COUNT + 1)); fi
            done
          done
          
          if [ $FILES_COPIED_COUNT -eq 0 ]; then
            echo "åœ¨ $TARGET_PATH_ITEM ä¸­æœªæ‰¾åˆ°æ ‡å‡†æ¨¡å¼çš„å›ºä»¶ï¼Œå°è¯•å¤åˆ¶æ‰€æœ‰éè¾…åŠ©æ–‡ä»¶..." | tee -a ${{ env.DEBUG_LOG_FILE }}
            find "$TARGET_PATH_ITEM" -maxdepth 1 -type f \
              ! -name "*.manifest" ! -name "*.txt" ! -name "*.json" ! -name "*.buildinfo" ! -name "sha256sums" \
              ! -path "*/packages/*" \
              -exec cp -v -f {} "$CANDIDATE_FIRMWARE_DIR/" \; -print | while read -r file_copied; do
              if [ -n "$file_copied" ]; then FILES_COPIED_COUNT=$((FILES_COPIED_COUNT + 1)); fi
            done
          fi

          if [ $FILES_COPIED_COUNT -gt 0 ]; then
            echo "æˆåŠŸå¤åˆ¶ $FILES_COPIED_COUNT ä¸ªå›ºä»¶ç›¸å…³æ–‡ä»¶åˆ° $CANDIDATE_FIRMWARE_DIR" | tee -a ${{ env.DEBUG_LOG_FILE }}
            ls -lh "$CANDIDATE_FIRMWARE_DIR" | tee -a ${{ env.DEBUG_LOG_FILE }}
            # Copy .config used for this build
            if [ -f "/workdir/openwrt/.config" ]; then
              cp -v -f /workdir/openwrt/.config "$CANDIDATE_FIRMWARE_DIR/config.txt"
            fi
            echo "FIRMWARE=$CANDIDATE_FIRMWARE_DIR" >> $GITHUB_ENV
            FIRMWARE_DIR_PATH_SET="$CANDIDATE_FIRMWARE_DIR"
            echo "status=success" >> $GITHUB_OUTPUT
            break # Found firmware, exit loop
          else
            echo "è­¦å‘Š: åœ¨ $TARGET_PATH_ITEM (è¾“å‡ºåˆ° $CANDIDATE_FIRMWARE_DIR) ä¸­æœªæ‰¾åˆ°å¯ç”¨å›ºä»¶æ–‡ä»¶ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
            rm -rf "$CANDIDATE_FIRMWARE_DIR" # Clean up empty firmware dir
          fi
        done

        if [ -z "$FIRMWARE_DIR_PATH_SET" ]; then
          echo "è­¦å‘Šï¼šæœªèƒ½åœ¨ä»»ä½•æ ‡å‡†ç›®æ ‡ç›®å½•ä¸­æ‰¾åˆ°å›ºä»¶æ–‡ä»¶ã€‚å°†ä½¿ç”¨ç´§æ€¥å¤‡ç”¨æ–¹æ³•ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
          # Fallback if no specific firmware found
          BACKUP_DIR="/workdir/openwrt/bin/targets/fallback_firmware_collection"
          mkdir -p "$BACKUP_DIR"
          # Try to copy anything that looks like a firmware from anywhere in bin/targets (excluding packages dirs)
          find /workdir/openwrt/bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.img.gz" \) ! -path "*/packages/*" -exec cp -v -f {} "$BACKUP_DIR/" \;
          if [ -f "/workdir/openwrt/.config" ]; then
             cp -v -f /workdir/openwrt/.config "$BACKUP_DIR/config.txt"
          else
             echo "# Emergency .config backup - actual .config not found" > "$BACKUP_DIR/config.txt"
          fi
          echo "FIRMWARE=$BACKUP_DIR" >> $GITHUB_ENV
          FIRMWARE_DIR_PATH_SET="$BACKUP_DIR"
          echo "status=success" >> $GITHUB_OUTPUT # Ensure organize step outputs status
        fi
        
        # Create firmware.zip from the determined FIRMWARE_DIR_PATH_SET
        if [ -n "$FIRMWARE_DIR_PATH_SET" ] && [ -d "$FIRMWARE_DIR_PATH_SET" ] && [ "$(ls -A "$FIRMWARE_DIR_PATH_SET")" ]; then
          FIRMWARE_PARENT_DIR=$(dirname "$FIRMWARE_DIR_PATH_SET")
          FIRMWARE_BASENAME=$(basename "$FIRMWARE_DIR_PATH_SET")
          echo "åˆ›å»ºå›ºä»¶å‹ç¼©åŒ… ${FIRMWARE_PARENT_DIR}/${FIRMWARE_BASENAME}.zip ..." | tee -a ${{ env.DEBUG_LOG_FILE }}
          cd "$FIRMWARE_PARENT_DIR" && zip -r "${FIRMWARE_BASENAME}.zip" "$FIRMWARE_BASENAME"
          echo "FIRMWARE_ZIP=${FIRMWARE_PARENT_DIR}/${FIRMWARE_BASENAME}.zip" >> $GITHUB_ENV
          ls -lh "${FIRMWARE_PARENT_DIR}/${FIRMWARE_BASENAME}.zip" | tee -a ${{ env.DEBUG_LOG_FILE }}
        else
          echo "è­¦å‘Š: FIRMWARE ç›®å½• ($FIRMWARE_DIR_PATH_SET) æœªè®¾ç½®ã€ä¸æ˜¯ç›®å½•æˆ–ä¸ºç©ºï¼Œæ— æ³•åˆ›å»º firmware.zipã€‚" | tee -a ${{ env.DEBUG_LOG_FILE }}
          # To prevent issues if FIRMWARE_ZIP is expected, set it to a non-existent path or empty
          echo "FIRMWARE_ZIP=/tmp/no_firmware.zip" >> $GITHUB_ENV
        fi


    - name: ä¸Šä¼ å›ºä»¶ (Artifact)
      uses: actions/upload-artifact@main
      if: steps.organize.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true' && !cancelled()
      with:
        name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
        # Upload the zip if it exists and is non-empty, otherwise try the directory.
        # This needs a bit more shell logic to check if FIRMWARE_ZIP actually got created.
        # For now, relying on FIRMWARE_ZIP being set by previous step.
        path: |
          ${{ env.FIRMWARE_ZIP }}
          ${{ env.FIRMWARE }}/* # Fallback to directory if zip is not the primary target or if FIRMWARE_ZIP is dummy
        # To be safer: A dedicated step could check if FIRMWARE_ZIP is valid and choose path.
        # Example (conceptual, would need its own 'run' step to set an output):
        # path: ${{ steps.check_zip.outputs.upload_path || env.FIRMWARE }}

    - name: ç”Ÿæˆå‘å¸ƒæ ‡ç­¾
      id: tag
      if: steps.organize.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true' && !cancelled()
      run: |
        RELEASE_TAG_BASE=$(date +"%Y.%m.%d-%H%M")
        # Append device name if available, ensuring it's a valid tag component
        DEVICE_TAG_PART=$(echo "${{ env.DEVICE_NAME }}" | sed 's/[^a-zA-Z0-9._-]/-/g' | sed 's/^-//;s/-$//')
        if [ -n "$DEVICE_TAG_PART" ] && [ "$DEVICE_TAG_PART" != "_" ]; then
          FINAL_RELEASE_TAG="${RELEASE_TAG_BASE}${DEVICE_TAG_PART}"
        else
          FINAL_RELEASE_TAG="${RELEASE_TAG_BASE}"
        fi
        echo "RELEASE_TAG=${FINAL_RELEASE_TAG}" >> $GITHUB_OUTPUT
        
        echo "## OpenWrt Firmware Build ($(date +"%Y-%m-%d %H:%M")) ğŸ“¦" > release_body.txt
        echo "" >> release_body.txt
        echo "**Branch:** \`${{ env.REPO_BRANCH }}\`" >> release_body.txt
        echo "**Config:** \`${{ env.CONFIG_FILE }}\`" >> release_body.txt
        if [ -n "$DEVICE_TAG_PART" ] && [ "$DEVICE_TAG_PART" != "_" ]; then
            echo "**Device:** \`${{ env.DEVICE_NAME }}\`" >> release_body.txt
        fi
        echo "" >> release_body.txt
        echo "### å›ºä»¶ä¸‹è½½ Firmware Download" >> release_body.txt
        echo "è¯·åœ¨ä¸‹æ–¹ Assets ä¸­æ‰¾åˆ°å›ºä»¶æ–‡ä»¶ã€‚" >> release_body.txt
        echo "Please find firmware files in the Assets section below." >> release_body.txt
        echo "" >> release_body.txt
        echo "---" >> release_body.txt
        echo "âš ï¸ **åˆ·æœºå‰è¯·åŠ¡å¿…å¤‡ä»½é‡è¦æ•°æ®ï¼**" >> release_body.txt
        echo "âš ï¸ **Backup your important data before flashing!**" >> release_body.txt
        echo "" >> release_body.txt
        echo "_Built by GitHub Actions - Workflow: ${GITHUB_WORKFLOW}_" >> release_body.txt
        echo "status=success" >> $GITHUB_OUTPUT

    - name: ä¸Šä¼ å›ºä»¶åˆ°Releases
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success' && !cancelled()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        body_path: release_body.txt # Use the new release body file
        # Prefer uploading the zip if FIRMWARE_ZIP is valid and points to an existing file
        # This logic is tricky directly in 'files:', ideally FIRMWARE_ZIP is robustly set
        files: |
          ${{ env.FIRMWARE_ZIP }}
          ${{ env.FIRMWARE }}/* # Note: If FIRMWARE_ZIP is a dummy path, it might cause an error or upload a tiny dummy file.
          # A more robust way is to have the 'organize' step output the exact path to upload.

    - name: åˆ é™¤æ—§çš„Releases
      uses: dev-drprasad/delete-older-releases@master
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 3 # Keep only the 3 most recent releases
        delete_tags: true # Also delete the git tags associated with old releases
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
