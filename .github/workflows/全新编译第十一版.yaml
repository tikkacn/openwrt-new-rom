name: OpenWrt Build (Optimized Cache & Logic)

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH Debug (true/false)'
        required: false
        default: 'false'
      clean_build:
        description: 'Force Clean Build (ignore all caches) (true/false)'
        required: false
        default: 'false'
      config_file:
        description: 'Specify .config file name (in repo root)'
        required: false
        default: '.config' # Default to '.config', ensure this file exists

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default # Example feed conf URL
  CONFIG_FILE: ${{ github.event.inputs.config_file || '.config' }} # Use provided or default .config name
  DIY_P1_SH: diy-part1.sh # Placeholder name, content generated below
  DIY_P2_SH: diy-part2.sh # Placeholder name, content generated below
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Taipei # Set timezone for Taiwan

  # --- Cache Related Paths ---
  WORK_DIR: /workdir
  OPENWRT_DIR: /workdir/openwrt
  DL_DIR: /workdir/openwrt/dl
  STAGING_DIR: /workdir/openwrt/staging_dir
  BUILD_DIR: /workdir/openwrt/build_dir
  BUILD_DIR_HOST: /workdir/openwrt/build_dir/host
  # Note: Caching target-* might exceed 10GB limit. Included for potential speedup. Remove if cache save fails.
  BUILD_DIR_TARGET: /workdir/openwrt/build_dir/target-*
  BUILD_DIR_TOOLCHAIN: /workdir/openwrt/build_dir/toolchain-*
  CCACHE_DIR: /workdir/ccache
  BUILD_STATE_DIR: /workdir/build_state

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - name: Checkout Workflow Code
      uses: actions/checkout@v4

    - name: Maximize Build Space (using /workdir)
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 10240
        swap-size-mb: 4096
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir' # Mount large volume here

    - name: Additional Disk Cleanup & Check
      run: |
        echo "Cleaning additional disk space..."
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost /usr/share/swift /usr/local/julia* /opt/hostedtoolcache/CodeQL || true
        docker image prune -a -f || true
        docker system prune -af || true
        sudo apt-get clean
        sudo apt-get -y autoremove --purge
        sudo rm -rf /var/lib/apt/lists/*
        echo "Checking mount points and available space..."
        df -hT
        if ! mount | grep -q ' /workdir '; then
          echo "ERROR: /workdir is not mounted!"
          exit 1
        fi
        WORKDIR_AVAIL=$(df -m /workdir | tail -1 | awk '{print $4}')
        echo "/workdir Available Space: ${WORKDIR_AVAIL}MB"
        if [ "$WORKDIR_AVAIL" -lt 30720 ]; then
           echo "WARNING: /workdir available space is below 30GB."
        fi

    - name: Initialize Environment
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        echo "Updating package lists and installing dependencies..."
        sudo -E apt-get -qq update
        # Essential dependencies for OpenWrt build
        sudo -E apt-get -qq install -y --no-install-recommends \
          ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
          bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext \
          genisoimage git gperf haveged help2man intltool libelf-dev libfuse-dev libglib2.0-dev \
          libgmp3-dev libltdl-dev libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev \
          libpython3-dev libreadline-dev libssl-dev libtool libzstd-dev lrzsz \
          msmtp nano ninja-build p7zip p7zip-full patch pkgconf python3 python3-pyelftools \
          python3-setuptools qemu-utils rsync scons squashfs-tools subversion swig texinfo \
          uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev file \
          g++-multilib gcc-multilib # Ensure multilibs are installed
        sudo -E apt-get -qq clean
        sudo rm -rf /var/lib/apt/lists/*
        echo "Setting timezone to ${{ env.TZ }}..."
        sudo timedatectl set-timezone "$TZ"

        echo "Creating necessary directories (in /workdir)..."
        mkdir -p ${{ env.OPENWRT_DIR }} ${{ env.DL_DIR }} ${{ env.STAGING_DIR }} ${{ env.BUILD_DIR }} \
                 ${{ env.BUILD_DIR_HOST }} ${{ env.BUILD_STATE_DIR }} ${{ env.CCACHE_DIR }}
        # Ensure potential cache target dirs might exist before restore attempts
        mkdir -p ${{ env.BUILD_DIR_TOOLCHAIN }}
        mkdir -p ${{ env.BUILD_DIR }}/target-placeholder # Placeholder

        echo "Setting permissions for /workdir..."
        sudo chmod -R 777 ${{ env.WORK_DIR }} || echo "chmod failed, continuing..."

        echo "Creating placeholder DIY scripts..."
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}
        echo '# Placeholder for diy-part1.sh' >> $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}
        echo '# Add custom feeds or pre-config commands here' >> $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}
        chmod +x $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}

        echo '#!/bin/bash' > $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# Placeholder for diy-part2.sh' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# Add custom configurations or package modifications here' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# Example: Modify default IP' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# sed -i "s/192.168.1.1/192.168.10.1/g" package/base-files/files/bin/config_generate' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# Example: Modify hostname in default settings' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo 'sed -i "s/OpenWrt /MyCustom_OpenWrt /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }} # Example customization
        chmod +x $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}

        echo "Checking for config file: $GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}"
        # --- Start: Block for creating default config ---
        if [ ! -f "$GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}" ]; then
          echo "WARNING: Config file '$GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}' not found! Creating minimal default config."
          # Create a minimal default config using heredoc if the specified one is missing
          # Use quotes around filename variable for safety
          cat > "$GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}" << EOF
CONFIG_TARGET_x86=y
CONFIG_TARGET_x86_64=y
CONFIG_TARGET_x86_64_DEVICE_generic=y
CONFIG_PACKAGE_luci=y
# Add other essential minimal packages if needed below
EOF  # <<< CRITICAL: This 'EOF' marker MUST be at the start of the line with NO leading spaces or tabs!
        else
            echo "Config file found: $GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}"
        fi # <<< CRITICAL: This 'fi' MUST exist to close the 'if' statement correctly.
        # --- End: Block for creating default config ---

        echo "Environment initialization complete."
        df -h

    - name: Clone OpenWrt Source & Configure Feeds
      working-directory: ${{ env.WORK_DIR }}
      run: |
        echo "Cloning OpenWrt source (${{ env.REPO_URL }} branch ${{ env.REPO_BRANCH }})..."
        retry_count=0
        max_retries=3
        until git clone --depth 1 $REPO_URL -b $REPO_BRANCH openwrt; do
          retry_count=$((retry_count+1))
          if [ $retry_count -ge $max_retries ]; then
            echo "ERROR: Failed to clone repository after $max_retries retries."
            exit 1
          fi
          echo "Clone failed, retrying ($retry_count/$max_retries)..."
          sleep 5
          rm -rf openwrt # Clean up failed clone attempt
        done

        cd openwrt
        echo "Creating symlink $GITHUB_WORKSPACE/openwrt -> ${{ env.OPENWRT_DIR }}"
        ln -sf ${{ env.OPENWRT_DIR }} $GITHUB_WORKSPACE/openwrt || echo "Failed to create symlink, maybe it exists."

        echo "Setting script permissions..."
        find . -maxdepth 1 -type f -name "*.sh" -exec chmod +x {} \; || true

        echo "Downloading feeds.conf.default from ${{ env.FEEDS_CONF_URL }}..."
        curl -L -o feeds.conf.default "${{ env.FEEDS_CONF_URL }}" || echo "WARNING: Failed to download feeds.conf.default, using repository default."
        echo "Current feeds.conf.default content:"
        cat feeds.conf.default

        echo "Removing .git directory..."
        rm -rf .git

        echo "Creating logs directory..."
        mkdir -p logs

        echo "Source clone and initial setup complete."

    # --- Cache Restore ---
    - name: Restore Build Essentials Cache (dl, staging_dir, partial build_dir)
      uses: actions/cache/restore@v4
      if: inputs.clean_build != 'true'
      id: cache-build-essentials
      with:
        path: |
          ${{ env.DL_DIR }}
          ${{ env.STAGING_DIR }}
          ${{ env.BUILD_DIR_HOST }}
          ${{ env.BUILD_DIR_TOOLCHAIN }}
          ${{ env.BUILD_DIR_TARGET }} # WARNING: This might exceed 10GB cache limit! Remove if needed.
        key: build-essentials-${{ runner.os }}-${{ env.REPO_BRANCH }}
        # Example restore-keys for more flexibility:
        # restore-keys: |
        #   build-essentials-${{ runner.os }}-${{ env.REPO_BRANCH }}-

    - name: Restore CCACHE Cache
      uses: actions/cache/restore@v4
      if: inputs.clean_build != 'true'
      id: cache-ccache
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: Restore Build State Cache (MD5s)
      uses: actions/cache/restore@v4
      if: inputs.clean_build != 'true'
      id: cache-state
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: Check Cache Restore Status
      run: |
        echo "--- Cache Restore Status ---"
        echo "Build Essentials Cache Hit: ${{ steps.cache-build-essentials.outputs.cache-hit == 'true' && 'Yes' || 'No' }}"
        echo "CCACHE Cache Hit: ${{ steps.cache-ccache.outputs.cache-hit == 'true' && 'Yes' || 'No' }}"
        echo "Build State Cache Hit: ${{ steps.cache-state.outputs.cache-hit == 'true' && 'Yes' || 'No' }}"
        echo "--- Checking Cache Directory Sizes (Post Restore) ---"
        du -sh ${{ env.DL_DIR }} 2>/dev/null || echo "${{ env.DL_DIR }} not found or empty"
        du -sh ${{ env.STAGING_DIR }} 2>/dev/null || echo "${{ env.STAGING_DIR }} not found or empty"
        du -sh ${{ env.BUILD_DIR_HOST }} 2>/dev/null || echo "${{ env.BUILD_DIR_HOST }} not found or empty"
        du -sh ${{ env.BUILD_DIR_TOOLCHAIN }} 2>/dev/null || echo "${{ env.BUILD_DIR_TOOLCHAIN }} not found or empty"
        du -sh ${{ env.BUILD_DIR_TARGET }} 2>/dev/null || echo "${{ env.BUILD_DIR_TARGET }} not found or empty"
        du -sh ${{ env.CCACHE_DIR }} 2>/dev/null || echo "${{ env.CCACHE_DIR }} not found or empty"
        du -sh ${{ env.BUILD_STATE_DIR }} 2>/dev/null || echo "${{ env.BUILD_STATE_DIR }} not found or empty"
        echo "--------------------------"
        if [ -d "${{ env.STAGING_DIR }}/toolchain-"* ]; then
          echo "Toolchain directory detected (likely from cache)."
        else
          echo "Toolchain directory not detected, expect toolchain compilation."
        fi
        df -h

    - name: Configure Build Environment (Feeds, Config, DIY)
      working-directory: ${{ env.OPENWRT_DIR }}
      run: |
        echo "Running DIY script Part 1..."
        $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}

        echo "Updating and installing Feeds..."
        ./scripts/feeds update -a
        ./scripts/feeds install -a

        echo "Copying custom files (if 'files' directory exists)..."
        if [ -e "$GITHUB_WORKSPACE/files" ]; then
          echo "Found 'files' directory, copying contents..."
          cp -r $GITHUB_WORKSPACE/files ./files
        else
            echo "'files' directory not found, skipping."
        fi

        echo "Copying .config file (${{ env.CONFIG_FILE }})..."
        cp "$GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}" ./.config

        echo "Backing up initial .config..."
        cp .config .config.input

        echo "Running DIY script Part 2..."
        $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}

        echo "Forcing CCACHE=y and AUTOREBUILD=n/AUTOREMOVE=n in .config..."
        # Ensure CCACHE is enabled for build speedup
        if ! grep -q "CONFIG_CCACHE=y" .config; then
           echo "CONFIG_CCACHE=y" >> .config
           echo "Added CONFIG_CCACHE=y"
        fi
        # Prevent unnecessary rebuild checks/package removal
        if ! grep -q "CONFIG_AUTOREBUILD=n" .config; then
           echo "CONFIG_AUTOREBUILD=n" >> .config
           echo "Added CONFIG_AUTOREBUILD=n"
        fi
        if ! grep -q "CONFIG_AUTOREMOVE=n" .config; then
           echo "CONFIG_AUTOREMOVE=n" >> .config
           echo "Added CONFIG_AUTOREMOVE=n"
        fi

        echo "Ensuring essential image generation options are set..."
        configs_added=0
        ensure_config() {
          grep -q "$1" .config || { echo "$1" >> .config; echo "Added config: $1"; configs_added=1; }
        }
        # Add common essential configs, adjust if your target needs different types
        ensure_config "CONFIG_TARGET_ROOTFS_SQUASHFS=y"
        ensure_config "CONFIG_TARGET_IMAGES_GZIP=y"

        # Add platform specific image configs (example for x86)
        if grep -q "CONFIG_TARGET_x86=y" .config; then
          ensure_config "CONFIG_GRUB_IMAGES=y"
          ensure_config "CONFIG_TARGET_IMAGES_PAD=y"
        fi

        echo "Running make defconfig to finalize .config..."
        make defconfig

        echo "Checking for missing packages after defconfig..."
        grep "^CONFIG_PACKAGE_.*=y" .config.input | sort > packages_input.txt || true
        grep "^CONFIG_PACKAGE_.*=y" .config | sort > packages_defconfig.txt || true
        comm -23 packages_input.txt packages_defconfig.txt > missing_packages.txt
        if [ -s missing_packages.txt ]; then
          echo "WARNING: The following packages were in the input config but are missing after defconfig (check dependencies/conflicts):"
          cat missing_packages.txt
          # Optional: attempt to re-add and run defconfig again (might fail)
          # echo "Attempting to re-add missing packages..."
          # cat missing_packages.txt >> .config
          # make defconfig
        else
          echo "No packages appear missing after defconfig compared to input."
        fi
        rm -f packages_input.txt packages_defconfig.txt missing_packages.txt # Clean up temp files

        echo "Displaying key image options from final .config:"
        grep -E "CONFIG_TARGET_ROOTFS|CONFIG_TARGET_IMAGES|CONFIG_GRUB|CONFIG_ISO|CONFIG_VDI|CONFIG_VMDK|CONFIG_QCOW2" .config || echo "No standard image options found."

        echo "Comparing input .config with final .config (showing differences)..."
        diff -u .config.input .config > logs/config_diff.txt || echo "Config has no differences or only additions."
        echo "--- Config Diff (Top 50 Lines) ---"
        cat logs/config_diff.txt | head -n 50
        echo "--- End Config Diff ---"

        echo "Build environment configuration complete."
        df -h

    - name: Check Feeds Source Changes
      id: check-feeds
      working-directory: ${{ env.OPENWRT_DIR }}
      run: |
        echo "Calculating current feeds Makefiles hash..."
        mkdir -p ${{ env.BUILD_STATE_DIR }}
        # Hash all Makefiles within feeds directories
        find feeds -type f -name "Makefile" -exec sha256sum {} \; | sort | sha256sum | awk '{print $1}' > ${{ env.BUILD_STATE_DIR }}/current_feeds.sha256
        CURRENT_FEEDS_HASH=$(cat ${{ env.BUILD_STATE_DIR }}/current_feeds.sha256)
        # Read previous hash, default to "null" if file doesn't exist
        PREVIOUS_FEEDS_HASH=$(cat ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256 2>/dev/null || echo "null")

        echo "Current Feeds Hash: $CURRENT_FEEDS_HASH"
        echo "Previous Feeds Hash: $PREVIOUS_FEEDS_HASH"

        if [ "$CURRENT_FEEDS_HASH" != "$PREVIOUS_FEEDS_HASH" ]; then
          echo "Feeds have changed since last build."
          echo "feeds_changed=true" >> $GITHUB_ENV
        else
          echo "Feeds have not changed."
          echo "feeds_changed=false" >> $GITHUB_ENV
        fi
        # Store current hash for the next run (saved via build state cache)
        cp ${{ env.BUILD_STATE_DIR }}/current_feeds.sha256 ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256

    - name: SSH Debug Session (if requested)
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    - name: Download Packages (with retry)
      working-directory: ${{ env.OPENWRT_DIR }}
      id: download
      run: |
        echo "Starting package download..."
        MAX_RETRIES=3
        RETRY_WAIT=15
        DOWNLOAD_SUCCESS=false

        for (( i=1; i<=MAX_RETRIES; i++ )); do
          echo "Download attempt $i/$MAX_RETRIES..."
          if make download -j$(nproc) V=s; then
            echo "Package download successful."
            DOWNLOAD_SUCCESS=true
            break
          fi
          if [ $i -lt $MAX_RETRIES ]; then
            echo "Download failed, waiting $RETRY_WAIT seconds before retry..."
            sleep $RETRY_WAIT
          else
            echo "ERROR: Package download failed after $MAX_RETRIES attempts."
            # Optionally try one last time with -j1 for detailed log
            # make download -j1 V=s || true
          fi
        done

        if [ "$DOWNLOAD_SUCCESS" = false ]; then
          echo "download_status=failed" >> $GITHUB_OUTPUT
          echo "WARNING: Proceeding to compile, but some packages might be missing!"
        else
           echo "download_status=success" >> $GITHUB_OUTPUT
        fi

        echo "Configuring CCACHE post-download..."
        mkdir -p ${{ env.CCACHE_DIR }}
        export CCACHE_DIR="${{ env.CCACHE_DIR }}"
        export PATH="/usr/lib/ccache:$PATH"
        ccache -o cache_dir="${{ env.CCACHE_DIR }}"
        ccache -o max_size=8G  # Set cache size limit
        ccache -z # Reset stats before build
        echo "--- CCACHE Status (Before Compile) ---"
        ccache -s
        echo "------------------------------------"
        df -h

    - name: Smart Compile Firmware (Core Build Step)
      working-directory: ${{ env.OPENWRT_DIR }}
      id: compile
      run: |
        echo "Starting smart firmware compilation..."
        export CCACHE_DIR="${{ env.CCACHE_DIR }}"
        export PATH="/usr/lib/ccache:$PATH"
        NPROC=$(nproc)
        echo "Using $NPROC threads for compilation."

        # --- Determine Build Strategy ---
        DO_FULL_BUILD=0
        DO_PACKAGE_BUILD=0

        echo "Calculating config MD5 hashes..."
        # Use finalized .config after defconfig for comparison
        TOOLCHAIN_CONFIG=$(grep "^CONFIG_TARGET" .config | sort)
        TOOLCHAIN_MD5=$(echo "$TOOLCHAIN_CONFIG" | md5sum | awk '{print $1}')
        PACKAGE_CONFIG=$(grep "^CONFIG_PACKAGE" .config | sort)
        PACKAGE_MD5=$(echo "$PACKAGE_CONFIG" | md5sum | awk '{print $1}')

        PREVIOUS_TOOLCHAIN_MD5=$(cat ${{ env.BUILD_STATE_DIR }}/toolchain.md5 2>/dev/null || echo "null")
        PREVIOUS_PACKAGE_MD5=$(cat ${{ env.BUILD_STATE_DIR }}/package.md5 2>/dev/null || echo "null")

        echo "Current Toolchain Config MD5: $TOOLCHAIN_MD5 (Previous: $PREVIOUS_TOOLCHAIN_MD5)"
        echo "Current Package Config MD5: $PACKAGE_MD5 (Previous: $PREVIOUS_PACKAGE_MD5)"
        echo "Feeds Changed: ${{ env.feeds_changed }}"
        echo "Force Clean Build Input: ${{ github.event.inputs.clean_build }}"

        # Decision logic
        if [ "${{ github.event.inputs.clean_build }}" = "true" ]; then
            echo "Strategy: Force clean build requested -> Full Compile"
            DO_FULL_BUILD=1
        elif [ "$TOOLCHAIN_MD5" != "$PREVIOUS_TOOLCHAIN_MD5" ]; then
            echo "Strategy: Toolchain config changed -> Full Compile"
            DO_FULL_BUILD=1
        elif [ "$PACKAGE_MD5" != "$PREVIOUS_PACKAGE_MD5" ]; then
            echo "Strategy: Package config changed -> Package Compile"
            DO_PACKAGE_BUILD=1
        elif [ "${{ env.feeds_changed }}" = "true" ]; then
            echo "Strategy: Feeds changed -> Package Compile (needs dependency re-check)"
            DO_PACKAGE_BUILD=1
        else
            echo "Strategy: Config and Feeds unchanged -> Minimal Incremental Compile"
        fi

        # --- Execute Build ---
        COMPILE_START_TIME=$(date +%s)
        BUILD_LOG="logs/compile_$(date +%Y%m%d_%H%M%S).log"
        touch $BUILD_LOG # Ensure log file exists
        compile_exit_code=0 # Default to success

        if [ $DO_FULL_BUILD -eq 1 ]; then
            echo "Executing Full Compile..."
            # Tools and Toolchain compile first (make should handle cache/skipping)
            echo "Compiling tools/toolchain (if necessary)..."
            if ! make tools/compile -j$NPROC V=s; then make tools/compile -j1 V=s; fi
            tools_exit_code=$?
            if [ $tools_exit_code -ne 0 ]; then echo "ERROR: tools/compile failed!"; compile_exit_code=$tools_exit_code; fi

            if [ $compile_exit_code -eq 0 ]; then
              if ! make toolchain/compile -j$NPROC V=s; then make toolchain/compile -j1 V=s; fi
              toolchain_exit_code=$?
              if [ $toolchain_exit_code -ne 0 ]; then echo "ERROR: toolchain/compile failed!"; compile_exit_code=$toolchain_exit_code; fi
            fi

            # Full firmware build if toolchain succeeded
            if [ $compile_exit_code -eq 0 ]; then
              echo "Executing full firmware build (make V=s)..."
              make -j$NPROC V=s 2>&1 | tee $BUILD_LOG
              compile_exit_code=${PIPESTATUS[0]}
            fi

        elif [ $DO_PACKAGE_BUILD -eq 1 ]; then
            echo "Executing Package Compile..."
            # *** CRITICAL: No 'make package/clean' here! ***
            echo "Compiling packages (make package/compile V=s)..."
            make package/compile -j$NPROC V=s 2>&1 | tee $BUILD_LOG
            compile_exit_code=${PIPESTATUS[0]}

            if [ $compile_exit_code -eq 0 ]; then
              echo "Packages compiled, generating index and installing target..."
              if ! make package/index -j$NPROC V=s; then make package/index -j1 V=s; fi
              if ! make target/install -j$NPROC V=s 2>&1 | tee -a $BUILD_LOG; then # Append to log
                 # Try single thread if parallel failed
                 make target/install -j1 V=s 2>&1 | tee -a $BUILD_LOG
              fi
              # Get exit code from the final make command attempt
              compile_exit_code=${PIPESTATUS[0]}
            fi
        else
            echo "Executing Minimal Incremental Compile (make V=s)..."
            make -j$NPROC V=s 2>&1 | tee $BUILD_LOG
            compile_exit_code=${PIPESTATUS[0]}
        fi

        COMPILE_END_TIME=$(date +%s)
        COMPILE_DURATION=$((COMPILE_END_TIME - COMPILE_START_TIME))
        echo "Compile phase duration: ${COMPILE_DURATION} seconds."

        # --- Post Compile ---
        # Save MD5s for next run comparison regardless of exit status (for debugging failed runs)
        echo "Saving current config MD5s..."
        mkdir -p ${{ env.BUILD_STATE_DIR }}
        echo "$TOOLCHAIN_MD5" > ${{ env.BUILD_STATE_DIR }}/toolchain.md5
        echo "$PACKAGE_MD5" > ${{ env.BUILD_STATE_DIR }}/package.md5
        cp .config "${{ env.BUILD_STATE_DIR }}/config_$( [ $compile_exit_code -eq 0 ] && echo "success" || echo "failure" ).txt" || true
        cp $BUILD_LOG "${{ env.BUILD_STATE_DIR }}/compile_$( [ $compile_exit_code -eq 0 ] && echo "success" || echo "failure" ).log" || true


        if [ $compile_exit_code -ne 0 ]; then
            echo "ERROR: Compilation failed with exit code $compile_exit_code !"
            echo "Check log file: $BUILD_LOG and potentially the saved state in artifacts."
            exit 1 # Exit script with failure code
        fi

        echo "Compilation finished successfully."

        # Extract device name and set date for artifacts/releases
        DEVICE_NAME_RAW=$(grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' | head -n 1)
        DEVICE_NAME_CLEAN=$(echo "$DEVICE_NAME_RAW" | tr -cd '[:alnum:]_-' | sed 's/^_*//;s/_*$//') # Clean illegal characters
        echo "Extracted device name: ${DEVICE_NAME_CLEAN}"
        # Set fallback 'generic' if name is empty or invalid
        if [ -z "$DEVICE_NAME_CLEAN" ]; then DEVICE_NAME_CLEAN="generic"; fi
        echo "DEVICE_NAME=_${DEVICE_NAME_CLEAN}" >> $GITHUB_ENV
        echo "FILE_DATE=_$(date +"%Y%m%d_%H%M")" >> $GITHUB_ENV

        echo "status=success" >> $GITHUB_OUTPUT # Output for subsequent steps

        echo "--- CCACHE Stats (After Compile) ---"
        ccache -s
        echo "-----------------------------------"
        df -h

    - name: Check Firmware Generation Result
      id: check_firmware
      working-directory: ${{ env.OPENWRT_DIR }}
      # Run only if compile step reported success
      if: steps.compile.outputs.status == 'success'
      run: |
        echo "Checking generated firmware files..."
        FIRMWARE_DIR="bin/targets"
        if [ ! -d "$FIRMWARE_DIR" ] || [ -z "$(ls -A $FIRMWARE_DIR)" ]; then
            echo "ERROR: Firmware output directory '$FIRMWARE_DIR' is missing or empty! Build likely failed to produce targets."
            echo "Listing 'bin/' directory contents:"
            ls -lA bin/ || true
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
        fi

        echo "Searching for common firmware file patterns in '$FIRMWARE_DIR'..."
        # List common firmware file types
        find "$FIRMWARE_DIR" -type f \( \
            -name "*sysupgrade*.bin" -o \
            -name "*factory*.bin" -o \
            -name "*combined*.img" -o \
            -name "*combined*.bin" -o \
            -name "*.img.gz" -o \
            -name "*rootfs.squashfs" -o \
            -name "*initramfs-kernel.bin" \
          \) -print -exec ls -lh {} \;

        FIRMWARE_FILES_COUNT=$(find "$FIRMWARE_DIR" -type f \( -name "*sysupgrade*.bin" -o -name "*factory*.bin" -o -name "*combined*.img" -o -name "*combined*.bin" -o -name "*.img.gz" -o -name "*rootfs.squashfs" -o -name "*initramfs-kernel.bin" \) | wc -l)

        if [ "$FIRMWARE_FILES_COUNT" -eq 0 ]; then
            echo "WARNING: No files matching common firmware patterns found in '$FIRMWARE_DIR'."
            echo "Listing all files found in '$FIRMWARE_DIR' for review:"
            find "$FIRMWARE_DIR" -type f -exec ls -lh {} \;
            echo "Proceeding, but artifact content might need manual verification."
            # Set status to warning instead of success if no standard files found
            echo "status=warning" >> $GITHUB_OUTPUT
        else
            echo "Found $FIRMWARE_FILES_COUNT potential firmware file(s)."
            echo "status=success" >> $GITHUB_OUTPUT
        fi

    # --- Cache Save ---
    - name: Save Build Essentials Cache
      uses: actions/cache/save@v4
      # Run even if cancelled or failed to save potentially useful partial state? No, default is success() or always() if needed. Let's stick to !cancelled().
      if: "!cancelled()"
      with:
        path: |
          ${{ env.DL_DIR }}
          ${{ env.STAGING_DIR }}
          ${{ env.BUILD_DIR_HOST }}
          ${{ env.BUILD_DIR_TOOLCHAIN }}
          ${{ env.BUILD_DIR_TARGET }} # Attempt to save target-* intermediates. If >10GB, save will fail.
        key: build-essentials-${{ runner.os }}-${{ env.REPO_BRANCH }} # Must match restore key

    - name: Save CCACHE Cache
      uses: actions/cache/save@v4
      if: "!cancelled()"
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: Save Build State Cache
      uses: actions/cache/save@v4
      if: "!cancelled()"
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: Organize Files for Upload
      id: organize
      # Run if compile succeeded OR if firmware check gave a warning (files exist but names might be odd)
      if: (steps.compile.outputs.status == 'success' || steps.check_firmware.outputs.status == 'warning') && env.UPLOAD_FIRMWARE == 'true' && !cancelled()
      run: |
        echo "Organizing files for artifact upload..."
        ARTIFACT_DIR="${{ env.WORK_DIR }}/openwrt-artifact"
        FIRMWARE_SRC_BASE="${{ env.OPENWRT_DIR }}/bin/targets"

        rm -rf "$ARTIFACT_DIR"
        mkdir -p "$ARTIFACT_DIR"

        # Find the target/subtarget directory (e.g., x86/64)
        # This assumes a structure like bin/targets/x86/64/
        TARGET_SUBDIR=$(find "$FIRMWARE_SRC_BASE" -mindepth 1 -maxdepth 1 -type d | head -n 1)
        if [ -z "$TARGET_SUBDIR" ]; then
          echo "ERROR: Cannot find target sub-directory in '$FIRMWARE_SRC_BASE'!"
          exit 1
        fi
        TARGET_ARCH_DIR=$(find "$TARGET_SUBDIR" -mindepth 1 -maxdepth 1 -type d | head -n 1)
         if [ -z "$TARGET_ARCH_DIR" ]; then
          echo "WARNING: Cannot find arch sub-directory in '$TARGET_SUBDIR'! Using '$TARGET_SUBDIR' directly."
          TARGET_ARCH_DIR=$TARGET_SUBDIR # Fallback to the first level dir
        fi

        echo "Copying files from '$TARGET_ARCH_DIR' to '$ARTIFACT_DIR'"
        # Copy all files from the deepest target directory found
        cp -vf "$TARGET_ARCH_DIR"/* "$ARTIFACT_DIR/" || echo "WARNING: Error occurred during file copy."

        # Copy build config for reference
        CONFIG_SRC="${{ env.BUILD_STATE_DIR }}/config_success.txt"
        if [ -f "$CONFIG_SRC" ]; then
            cp "$CONFIG_SRC" "$ARTIFACT_DIR/build_config.txt"
        elif [ -f "${{ env.OPENWRT_DIR }}/.config" ]; then # Fallback to current .config
             cp "${{ env.OPENWRT_DIR }}/.config" "$ARTIFACT_DIR/build_config.txt"
        fi
        # Copy the compile log
        LOG_SRC="${{ env.BUILD_STATE_DIR }}/compile_success.log"
         if [ -f "$LOG_SRC" ]; then
            cp "$LOG_SRC" "$ARTIFACT_DIR/compile_success.log"
        fi
        # Copy Feeds config
        if [ -f "${{ env.OPENWRT_DIR }}/feeds.conf.default" ]; then
             cp "${{ env.OPENWRT_DIR }}/feeds.conf.default" "$ARTIFACT_DIR/feeds.conf.default.txt"
        fi
        # Copy manifest if it exists
        MANIFEST_FILE=$(find "$TARGET_ARCH_DIR" -maxdepth 1 -name "*.manifest" | head -n 1)
        if [ -n "$MANIFEST_FILE" ] && [ -f "$MANIFEST_FILE" ]; then
             cp "$MANIFEST_FILE" "$ARTIFACT_DIR/manifest.txt"
        fi


        if [ -z "$(ls -A "$ARTIFACT_DIR")" ]; then
            echo "ERROR: Artifact directory '$ARTIFACT_DIR' is empty after organizing!"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
        else
            echo "Files organized successfully in '$ARTIFACT_DIR'."
            ls -alh "$ARTIFACT_DIR"
            echo "ARTIFACT_PATH=${ARTIFACT_DIR}" >> $GITHUB_ENV # Set env var for upload step
            echo "status=success" >> $GITHUB_OUTPUT
        fi

    - name: Upload Firmware Artifact
      uses: actions/upload-artifact@v4
      if: steps.organize.outputs.status == 'success' && !cancelled()
      with:
        name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
        path: ${{ env.ARTIFACT_PATH }} # Use the path set in organize step
        retention-days: 7 # Adjust retention as needed

    - name: Generate Release Tag and Notes
      id: tag
      if: steps.organize.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true' && !cancelled()
      run: |
        RELEASE_TAG="build-$(date +%Y%m%d-%H%M%S)"
        echo "Generated Release Tag: ${RELEASE_TAG}"
        echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT

        # Create release notes file
        cat > release_notes.md <<EOF
        ## OpenWrt Firmware Auto Build (${RELEASE_TAG})

        * **Build Time:** $(date +"%Y-%m-%d %H:%M:%S %Z") (Timezone: ${{ env.TZ }})
        * **Source Branch:** ${{ env.REPO_BRANCH }}
        * **Config File Used:** ${{ env.CONFIG_FILE }}
        * **Device Target (Extracted):** ${{ env.DEVICE_NAME }}

        **Included Files:** (Check assets below)
        * Firmware image file(s) (e.g., sysupgrade, factory)
        * `build_config.txt`: The OpenWrt .config used for this build.
        * `compile_success.log`: Main compilation log for this build.
        * `feeds.conf.default.txt`: Feeds configuration used.
        * `manifest.txt` (if generated)

        **NOTE:** Always back up your device configuration before flashing! This firmware is provided as-is without warranty.
        EOF
        echo "Release notes generated in release_notes.md"

    - name: Upload Firmware to GitHub Releases
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success' && !cancelled()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        name: "OpenWrt Auto Build ${{ steps.tag.outputs.RELEASE_TAG }}" # Release title
        body_path: release_notes.md # Path to release notes file
        # Upload all files from the organized artifact directory
        files: ${{ env.ARTIFACT_PATH }}/*
        prerelease: false # Set to true if this should be marked as a pre-release

    - name: Delete Older Releases (Keep 3)
      uses: dev-drprasad/delete-older-releases@v1.0.0
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 3 # Number of latest releases to keep
        delete_tags: true # Also delete the git tag associated with the old release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Final Cleanup (Optional)
      if: always() # Run even if previous steps fail
      run: |
        echo "Performing final cleanup..."
        # Optionally remove large directories to free up runner space if needed
        # Be cautious with rm -rf
        # rm -rf ${{ env.OPENWRT_DIR }}
        # rm -rf ${{ env.CCACHE_DIR }}
        # rm -rf ${{ env.BUILD_STATE_DIR }}
        echo "Cleanup finished."
