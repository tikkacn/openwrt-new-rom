name: 全新编译第十一版(优化缓存和编译逻辑)

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH调试 (true/false)'
        required: false
        default: 'false'
      clean_build:
        description: '强制完全重新编译 (忽略所有缓存) (true/false)'
        required: false
        default: 'false'
      config_file:
        description: '指定使用的配置文件名 (在仓库根目录)'
        required: false
        default: '增量缓存优化.config' # Make sure this file exists in your repo

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE: ${{ github.event.inputs.config_file || '增量缓存优化.config' }} # Default config file name
  DIY_P1_SH: diy-part1.sh # Placeholder name, content generated below
  DIY_P2_SH: diy-part2.sh # Placeholder name, content generated below
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai

  # --- Cache Related Paths ---
  # Note: /workdir is the mounted build volume
  WORK_DIR: /workdir
  OPENWRT_DIR: /workdir/openwrt
  DL_DIR: /workdir/openwrt/dl
  STAGING_DIR: /workdir/openwrt/staging_dir
  BUILD_DIR: /workdir/openwrt/build_dir
  # Specific build_dir parts to attempt caching:
  BUILD_DIR_HOST: /workdir/openwrt/build_dir/host
  BUILD_DIR_TARGET: /workdir/openwrt/build_dir/target-* # May exceed cache limit!
  BUILD_DIR_TOOLCHAIN: /workdir/openwrt/build_dir/toolchain-*
  # CCache
  CCACHE_DIR: /workdir/ccache
  # Build state (MD5s, etc.)
  BUILD_STATE_DIR: /workdir/build_state

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - name: 检出工作流代码
      uses: actions/checkout@v4 # Updated to v4

    - name: 优化磁盘空间 (使用 /workdir)
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 10240 # Reduced root reserve slightly
        swap-size-mb: 4096
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir' # Mount large volume at /workdir

    - name: 额外清理磁盘空间并检查
      run: |
        echo "清理额外磁盘空间..."
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost /usr/share/swift /usr/local/julia* /opt/hostedtoolcache/CodeQL || true
        docker image prune -a -f || true
        docker system prune -af || true
        sudo apt-get clean
        sudo apt-get autoremove -y --purge
        echo "检查挂载点和可用空间..."
        df -hT
        # Ensure /workdir is mounted and has significant space
        if ! mount | grep -q ' /workdir '; then
          echo "错误: /workdir 未挂载!"
          exit 1
        fi
        WORKDIR_AVAIL=$(df -m /workdir | tail -1 | awk '{print $4}')
        echo "/workdir 可用空间: ${WORKDIR_AVAIL}MB"
        if [ "$WORKDIR_AVAIL" -lt 30720 ]; then # Check for at least 30GB in /workdir
           echo "警告：/workdir 可用空间低于 30GB"
        fi

    - name: 初始化环境
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        echo "更新软件包列表并安装依赖..."
        sudo -E apt-get -qq update
        # Reduced redundant packages, kept essentials for OpenWrt build
        sudo -E apt-get -qq install -y --no-install-recommends \
          ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
          bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext \
          genisoimage git gperf haveged help2man intltool libelf-dev libfuse-dev libglib2.0-dev \
          libgmp3-dev libltdl-dev libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev \
          libpython3-dev libreadline-dev libssl-dev libtool libzstd-dev lrzsz \
          msmtp nano ninja-build p7zip p7zip-full patch pkgconf python3 python3-pyelftools \
          python3-setuptools qemu-utils rsync scons squashfs-tools subversion swig texinfo \
          uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev file \
          g++-multilib gcc-multilib # Ensure multilibs are installed
        sudo -E apt-get -qq clean
        sudo rm -rf /var/lib/apt/lists/*
        sudo timedatectl set-timezone "$TZ"

        echo "创建必要的目录 (在 /workdir)..."
        mkdir -p ${{ env.OPENWRT_DIR }} ${{ env.DL_DIR }} ${{ env.STAGING_DIR }} ${{ env.BUILD_DIR }} \
                 ${{ env.BUILD_DIR_HOST }} ${{ env.BUILD_STATE_DIR }} ${{ env.CCACHE_DIR }}
        # Ensure toolchain and target dirs might exist for cache restore
        mkdir -p ${{ env.BUILD_DIR_TOOLCHAIN }}
        # Placeholder for target dir, actual name depends on config:
        mkdir -p ${{ env.BUILD_DIR }}/target-placeholder

        # Set permissions for /workdir
        sudo chmod -R 777 ${{ env.WORK_DIR }} || echo "chmod failed, continuing..."

        echo "创建空的 DIY 脚本占位符..."
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}
        echo '# Placeholder for diy-part1.sh' >> $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}
        echo '# Add custom feeds or pre-config commands here if needed' >> $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}
        chmod +x $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}

        echo '#!/bin/bash' > $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# Placeholder for diy-part2.sh' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# Add custom configurations or package modifications here' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# Example: Modify default IP' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo '# sed -i "s/192.168.1.1/192.168.10.1/g" package/base-files/files/bin/config_generate' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}
        echo 'sed -i "s/OpenWrt /Tikha_OpenWrt /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }} # Example customization
        chmod +x $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}

        echo "检查配置文件 ${{ env.CONFIG_FILE }}..."
        if [ ! -f "$GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}" ]; then
          echo "警告：配置文件 $GITHUB_WORKSPACE/${{ env.CONFIG_FILE }} 不存在！将使用最小化默认配置。"
          # Create a minimal default config if the specified one is missing
          cat > $GITHUB_WORKSPACE/${{ env.CONFIG_FILE }} << EOF
CONFIG_TARGET_x86=y
CONFIG_TARGET_x86_64=y
CONFIG_TARGET_x86_64_DEVICE_generic=y
CONFIG_PACKAGE_luci=y
# Add other essential minimal packages if needed
EOF
        else
            echo "找到配置文件: $GITHUB_WORKSPACE/${{ env.CONFIG_FILE }}"
        fi
        echo "环境初始化完成。"
        df -h

    - name: 克隆OpenWrt源代码并配置Feeds
      working-directory: ${{ env.WORK_DIR }}
      run: |
        echo "克隆 OpenWrt 源码 (${{ env.REPO_URL }} branch ${{ env.REPO_BRANCH }})..."
        # Retry clone for network issues
        retry_count=0
        max_retries=3
        until git clone --depth 1 $REPO_URL -b $REPO_BRANCH openwrt; do
          retry_count=$((retry_count+1))
          if [ $retry_count -ge $max_retries ]; then
            echo "错误：克隆仓库失败，已达最大重试次数。"
            exit 1
          fi
          echo "克隆失败，重试 ($retry_count/$max_retries)..."
          sleep 5
          rm -rf openwrt # Clean up failed clone attempt
        done

        cd openwrt
        echo "创建软链接 $GITHUB_WORKSPACE/openwrt -> ${{ env.OPENWRT_DIR }}"
        ln -sf ${{ env.OPENWRT_DIR }} $GITHUB_WORKSPACE/openwrt || echo "创建软链接失败，可能已存在"

        echo "设置脚本执行权限..."
        find . -maxdepth 1 -type f -name "*.sh" -exec chmod +x {} \; || true

        echo "下载 feeds.conf.default..."
        curl -L -o feeds.conf.default "${{ env.FEEDS_CONF_URL }}" || echo "警告：无法下载 feeds.conf.default，将使用仓库默认配置"
        echo "当前 feeds.conf.default 内容:"
        cat feeds.conf.default

        echo "移除 .git 目录以节省空间..."
        rm -rf .git

        echo "创建日志目录..."
        mkdir -p logs

        echo "源码克隆和初步配置完成。"

    # --- 缓存恢复 ---
    - name: 恢复 Build Essentials 缓存 (dl, staging_dir, 部分 build_dir)
      uses: actions/cache/restore@v4 # Use restore action explicitly
      if: inputs.clean_build != 'true'
      id: cache-build-essentials
      with:
        path: |
          ${{ env.DL_DIR }}
          ${{ env.STAGING_DIR }}
          ${{ env.BUILD_DIR_HOST }}
          ${{ env.BUILD_DIR_TOOLCHAIN }}
          ${{ env.BUILD_DIR_TARGET }} # 注意: 此项可能导致超过10GB缓存限制!
        key: build-essentials-${{ runner.os }}-${{ env.REPO_BRANCH }}
        # restore-keys can be added if more flexible matching is needed

    - name: 恢复 CCACHE 缓存
      uses: actions/cache/restore@v4
      if: inputs.clean_build != 'true'
      id: cache-ccache
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: 恢复构建状态缓存 (MD5s)
      uses: actions/cache/restore@v4
      if: inputs.clean_build != 'true'
      id: cache-state
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: 检查缓存恢复状态
      run: |
        echo "--- 缓存恢复状态 ---"
        echo "Build Essentials 缓存命中: ${{ steps.cache-build-essentials.outputs.cache-hit == 'true' && '是' || '否' }}"
        echo "CCACHE 缓存命中: ${{ steps.cache-ccache.outputs.cache-hit == 'true' && '是' || '否' }}"
        echo "构建状态缓存命中: ${{ steps.cache-state.outputs.cache-hit == 'true' && '是' || '否' }}"
        echo "--- 检查缓存目录大小 (恢复后) ---"
        du -sh ${{ env.DL_DIR }} 2>/dev/null || echo "${{ env.DL_DIR }} 不存在或为空"
        du -sh ${{ env.STAGING_DIR }} 2>/dev/null || echo "${{ env.STAGING_DIR }} 不存在或为空"
        du -sh ${{ env.BUILD_DIR_HOST }} 2>/dev/null || echo "${{ env.BUILD_DIR_HOST }} 不存在或为空"
        du -sh ${{ env.BUILD_DIR_TOOLCHAIN }} 2>/dev/null || echo "${{ env.BUILD_DIR_TOOLCHAIN }} 不存在或为空"
        du -sh ${{ env.BUILD_DIR_TARGET }} 2>/dev/null || echo "${{ env.BUILD_DIR_TARGET }} 不存在或为空"
        du -sh ${{ env.CCACHE_DIR }} 2>/dev/null || echo "${{ env.CCACHE_DIR }} 不存在或为空"
        du -sh ${{ env.BUILD_STATE_DIR }} 2>/dev/null || echo "${{ env.BUILD_STATE_DIR }} 不存在或为空"
        echo "----------------------"
        # Basic check for toolchain existence after cache restore
        if [ -d "${{ env.STAGING_DIR }}/toolchain-"* ]; then
          echo "检测到工具链目录 (可能来自缓存)."
        else
          echo "未检测到工具链目录，预计将进行编译。"
        fi
        df -h

    - name: 配置编译环境 (Feeds, Config, DIY)
      working-directory: ${{ env.OPENWRT_DIR }}
      run: |
        echo "运行 DIY 脚本 Part 1..."
        $GITHUB_WORKSPACE/${{ env.DIY_P1_SH }}

        echo "更新并安装 Feeds..."
        ./scripts/feeds update -a
        ./scripts/feeds install -a

        echo "复制自定义文件 (如果存在)..."
        if [ -e "$GITHUB_WORKSPACE/files" ]; then
          echo "找到 'files' 目录，正在复制..."
          cp -r $GITHUB_WORKSPACE/files ./files
        else
            echo "'files' 目录不存在，跳过复制。"
        fi

        echo "复制配置文件 (${{ env.CONFIG_FILE }})..."
        cp $GITHUB_WORKSPACE/${{ env.CONFIG_FILE }} ./.config

        echo "备份原始输入配置..."
        cp .config .config.input

        echo "运行 DIY 脚本 Part 2..."
        $GITHUB_WORKSPACE/${{ env.DIY_P2_SH }}

        echo "强制添加 CCACHE 和禁用 AUTOREBUILD/AUTOREMOVE 到配置..."
        echo "CONFIG_CCACHE=y" >> .config # <--- 确保启用 CCACHE
        echo "CONFIG_AUTOREMOVE=n" >> .config
        echo "CONFIG_AUTOREBUILD=n" >> .config

        echo "确保必要的固件生成配置..."
        # This logic ensures basic image types are buildable if not specified
        # Adjust based on your target platform needs (e.g., different image types)
        configs_added=0
        ensure_config() {
          grep -q "$1" .config || { echo "$1" >> .config; echo "添加了配置: $1"; configs_added=1; }
        }
        ensure_config "CONFIG_TARGET_ROOTFS_SQUASHFS=y"
        ensure_config "CONFIG_TARGET_IMAGES_GZIP=y" # Common compression
        # ensure_config "CONFIG_TARGET_ROOTFS_TARGZ=y" # Usually less common for final image

        # Add platform specific image configs if needed (example for x86)
        if grep -q "CONFIG_TARGET_x86=y" .config; then
          ensure_config "CONFIG_GRUB_IMAGES=y"
          ensure_config "CONFIG_TARGET_IMAGES_PAD=y"
          # ensure_config "CONFIG_ISO_IMAGES=y" # If you need ISO
          # ensure_config "CONFIG_VDI_IMAGES=y" # If you need VDI
        fi

        echo "运行 make defconfig 生成完整配置..."
        make defconfig

        echo "检查 defconfig 后的包丢失情况..."
        grep "^CONFIG_PACKAGE_.*=y" .config.input | sort > packages_input.txt || true
        grep "^CONFIG_PACKAGE_.*=y" .config | sort > packages_defconfig.txt || true
        comm -23 packages_input.txt packages_defconfig.txt > missing_packages.txt
        if [ -s missing_packages.txt ]; then
          echo "警告：以下包在 defconfig 后缺失，可能是依赖或冲突导致，将尝试恢复："
          cat missing_packages.txt
          # Attempt to re-add missing packages and run defconfig again
          # This might loop or fail if there are real conflicts
          while read -r line; do
            # Ensure it's a valid package line
            if [[ "$line" == CONFIG_PACKAGE_*=y ]]; then
                echo "$line" >> .config
            fi
          done < missing_packages.txt
          echo "再次运行 make defconfig 尝试恢复包..."
          make defconfig
        else
          echo "所有输入配置项均在 defconfig 后保留，无明显缺失。"
        fi
        rm -f packages_input.txt packages_defconfig.txt missing_packages.txt # Clean up temp files

        echo "显示最终配置中的关键镜像生成选项:"
        grep -E "CONFIG_TARGET_ROOTFS|CONFIG_TARGET_IMAGES|CONFIG_GRUB|CONFIG_ISO|CONFIG_VDI|CONFIG_VMDK|CONFIG_QCOW2" .config || echo "未找到镜像相关配置"

        echo "比较输入配置和最终配置的差异..."
        diff -u .config.input .config > logs/config_diff.txt || echo "配置无差异或仅有添加项"
        cat logs/config_diff.txt | head -n 50 # Show first 50 lines of diff

        echo "编译环境配置完成。"
        df -h

    - name: 检查 Feeds 源码变化
      id: check-feeds
      working-directory: ${{ env.OPENWRT_DIR }}
      run: |
        echo "计算当前 feeds Makefiles 的哈希值..."
        mkdir -p ${{ env.BUILD_STATE_DIR }}
        # Hash all Makefiles in feeds directories
        find feeds -type f -name "Makefile" -exec sha256sum {} \; | sort | sha256sum | awk '{print $1}' > ${{ env.BUILD_STATE_DIR }}/current_feeds.sha256
        CURRENT_FEEDS_HASH=$(cat ${{ env.BUILD_STATE_DIR }}/current_feeds.sha256)
        PREVIOUS_FEEDS_HASH=$(cat ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256 2>/dev/null || echo "null")

        echo "当前 Feeds 哈希: $CURRENT_FEEDS_HASH"
        echo "上次 Feeds 哈希: $PREVIOUS_FEEDS_HASH"

        if [ "$CURRENT_FEEDS_HASH" != "$PREVIOUS_FEEDS_HASH" ]; then
          echo "Feeds 已变更，编译时将重新检查包依赖。"
          echo "feeds_changed=true" >> $GITHUB_ENV
        else
          echo "Feeds 未变更。"
          echo "feeds_changed=false" >> $GITHUB_ENV
        fi
        # Store current hash for the next run (will be saved with build state cache)
        cp ${{ env.BUILD_STATE_DIR }}/current_feeds.sha256 ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256

    - name: 开启SSH调试 (如果需要)
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    - name: 下载软件包 (带重试)
      working-directory: ${{ env.OPENWRT_DIR }}
      id: download
      run: |
        echo "开始下载软件包..."
        MAX_RETRIES=3
        RETRY_WAIT=15 # Increased wait time slightly

        # Use a subshell to avoid polluting global scope
        (
          retries=0
          until make download -j$(nproc) V=s; do
            retries=$((retries+1))
            if [ $retries -ge $MAX_RETRIES ]; then
              echo "错误：下载失败达到最大重试次数 ($MAX_RETRIES)！"
              # Try one last time with single thread and verbose output for logging
              make download -j1 V=s || echo "单线程下载仍然失败..." >&2
              # Exit the subshell with failure, but allow the main script to continue to compilation potentially
              exit 1
            fi
            echo "下载失败，等待 $RETRY_WAIT 秒后重试 ($retries/$MAX_RETRIES)..."
            sleep $RETRY_WAIT
          done
          echo "软件包下载成功。"
        ) || echo "download_status=failed" >> $GITHUB_OUTPUT # Record failure if subshell exits with non-zero

        # Always proceed, compilation step will handle potential missing downloads
        echo "下载步骤完成（可能部分失败）。"

        echo "配置 CCACHE (下载后)..."
        mkdir -p ${{ env.CCACHE_DIR }}
        export CCACHE_DIR="${{ env.CCACHE_DIR }}" # Ensure env var is set for ccache command
        export PATH="/usr/lib/ccache:$PATH"
        ccache -o cache_dir="${{ env.CCACHE_DIR }}"
        ccache -o max_size=8G  # Set cache size limit
        ccache -z # Reset stats before build
        ccache -s # Show initial stats
        df -h

    - name: 智能编译固件 (核心步骤)
      working-directory: ${{ env.OPENWRT_DIR }}
      id: compile
      run: |
        echo "开始智能编译固件..."
        export CCACHE_DIR="${{ env.CCACHE_DIR }}"
        export PATH="/usr/lib/ccache:$PATH" # Ensure ccache is in PATH for make
        NPROC=$(nproc)
        echo "使用 $NPROC 个线程进行编译。"

        # Function to handle potential build failures (simplified)
        handle_build_error() {
            local exit_code=$1
            local log_file=$2
            echo "错误：编译步骤返回非零退出码 ($exit_code)。"
            echo "查看日志文件: $log_file"
            # Add more sophisticated error analysis here if needed
            # e.g., check for "No space left on device", known compile errors etc.
            # For now, just report the error.
            return $exit_code # Propagate the error code
        }

        # --- Determine Build Strategy ---
        DO_FULL_BUILD=0
        DO_PACKAGE_BUILD=0

        echo "计算配置文件的 MD5 哈希值..."
        TOOLCHAIN_CONFIG=$(grep "^CONFIG_TARGET" .config | sort)
        TOOLCHAIN_MD5=$(echo "$TOOLCHAIN_CONFIG" | md5sum | awk '{print $1}')
        PACKAGE_CONFIG=$(grep "^CONFIG_PACKAGE" .config | sort)
        PACKAGE_MD5=$(echo "$PACKAGE_CONFIG" | md5sum | awk '{print $1}')

        PREVIOUS_TOOLCHAIN_MD5=$(cat ${{ env.BUILD_STATE_DIR }}/toolchain.md5 2>/dev/null || echo "null")
        PREVIOUS_PACKAGE_MD5=$(cat ${{ env.BUILD_STATE_DIR }}/package.md5 2>/dev/null || echo "null")

        echo "当前工具链配置 MD5: $TOOLCHAIN_MD5 (上次: $PREVIOUS_TOOLCHAIN_MD5)"
        echo "当前软件包配置 MD5: $PACKAGE_MD5 (上次: $PREVIOUS_PACKAGE_MD5)"
        echo "Feeds 变更: ${{ env.feeds_changed }}"
        echo "强制清理构建: ${{ github.event.inputs.clean_build }}"

        # Decision logic
        if [ "${{ github.event.inputs.clean_build }}" = "true" ]; then
            echo "策略：检测到强制清理构建选项，将执行完整编译。"
            DO_FULL_BUILD=1
        elif [ "$TOOLCHAIN_MD5" != "$PREVIOUS_TOOLCHAIN_MD5" ]; then
            echo "策略：工具链相关配置发生变化，需要完整编译。"
            DO_FULL_BUILD=1
            # Consider cleaning relevant build_dir parts if toolchain changes drastically?
            # For now, rely on make's dependency checking.
        elif [ "$PACKAGE_MD5" != "$PREVIOUS_PACKAGE_MD5" ]; then
            echo "策略：软件包配置发生变化，需要编译软件包。"
            DO_PACKAGE_BUILD=1
        elif [ "${{ env.feeds_changed }}" = "true" ]; then
            echo "策略：Feeds 发生变化，需要重新检查和编译软件包。"
            DO_PACKAGE_BUILD=1 # Treat feed change like package change
        else
            echo "策略：配置和 Feeds 均未变化，执行最小增量编译。"
        fi

        # --- Execute Build ---
        COMPILE_START_TIME=$(date +%s)
        BUILD_LOG="logs/compile_$(date +%Y%m%d_%H%M%S).log"
        touch $BUILD_LOG # Ensure log file exists

        if [ $DO_FULL_BUILD -eq 1 ]; then
            echo "执行完整编译..."
            # No clean needed usually, make handles dependencies. Cache should be ignored via input.
            # Compile tools/toolchain first (make will skip if cache/staging_dir is valid and config matches)
            echo "编译工具和工具链 (make 会根据缓存和配置跳过)..."
            make tools/compile -j$NPROC V=s || make tools/compile -j1 V=s || { handle_build_error $? $BUILD_LOG; exit 1; }
            make toolchain/compile -j$NPROC V=s || make toolchain/compile -j1 V=s || { handle_build_error $? $BUILD_LOG; exit 1; }

            echo "执行完整固件编译 (make V=s)..."
            make -j$NPROC V=s 2>&1 | tee $BUILD_LOG
            compile_exit_code=${PIPESTATUS[0]}

        elif [ $DO_PACKAGE_BUILD -eq 1 ]; then
            echo "执行软件包编译..."
            # *** CRITICAL: Removed make package/clean ***
            # Rely on make's dependency checking and ccache
            echo "编译软件包 (make package/compile V=s)..."
            make package/compile -j$NPROC V=s 2>&1 | tee $BUILD_LOG
            compile_exit_code=${PIPESTATUS[0]}

            if [ $compile_exit_code -eq 0 ]; then
              echo "软件包编译完成，生成索引并构建固件..."
              make package/index -j$NPROC V=s || make package/index -j1 V=s
              make target/install -j$NPROC V=s 2>&1 | tee -a $BUILD_LOG # Append to log
              compile_exit_code=${PIPESTATUS[0]} # Get exit code of target/install
            fi
        else
            echo "执行最小增量编译 (直接生成固件 make V=s)..."
            make -j$NPROC V=s 2>&1 | tee $BUILD_LOG
            compile_exit_code=${PIPESTATUS[0]}
        fi

        COMPILE_END_TIME=$(date +%s)
        COMPILE_DURATION=$((COMPILE_END_TIME - COMPILE_START_TIME))
        echo "编译步骤耗时: ${COMPILE_DURATION} 秒。"

        # Check exit code after attempting build
        if [ $compile_exit_code -ne 0 ]; then
            echo "错误：编译失败！退出码: $compile_exit_code"
            echo "查看日志: $BUILD_LOG"
            # Attempt to save build state even on failure for debugging
            mkdir -p ${{ env.BUILD_STATE_DIR }}
            echo "$TOOLCHAIN_MD5" > ${{ env.BUILD_STATE_DIR }}/toolchain.md5
            echo "$PACKAGE_MD5" > ${{ env.BUILD_STATE_DIR }}/package.md5
            cp .config ${{ env.BUILD_STATE_DIR }}/config_failed.txt || true
            cp $BUILD_LOG ${{ env.BUILD_STATE_DIR }}/compile_error.log || true
            exit 1 # Exit the script with failure
        fi

        echo "编译成功完成。"

        # Save MD5s for next run comparison
        echo "保存当前配置 MD5..."
        mkdir -p ${{ env.BUILD_STATE_DIR }}
        echo "$TOOLCHAIN_MD5" > ${{ env.BUILD_STATE_DIR }}/toolchain.md5
        echo "$PACKAGE_MD5" > ${{ env.BUILD_STATE_DIR }}/package.md5
        cp .config ${{ env.BUILD_STATE_DIR }}/config_last_successful.txt || true

        # Extract device name and set date for artifacts/releases
        DEVICE_NAME_RAW=$(grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' | head -n 1)
        DEVICE_NAME_CLEAN=$(echo "$DEVICE_NAME_RAW" | tr -cd '[:alnum:]_-' | sed 's/^_*//;s/_*$//') # Clean illegal characters
        echo "提取设备名: ${DEVICE_NAME_CLEAN}"
        echo "DEVICE_NAME=_${DEVICE_NAME_CLEAN:-generic}" >> $GITHUB_ENV # Fallback to generic
        echo "FILE_DATE=_$(date +"%Y%m%d_%H%M")" >> $GITHUB_ENV

        echo "status=success" >> $GITHUB_OUTPUT # Output for subsequent steps

        echo "--- CCACHE 统计信息 (编译后) ---"
        ccache -s
        echo "--------------------------------"
        df -h

    - name: 检查固件生成结果 (增强)
      id: check_firmware
      working-directory: ${{ env.OPENWRT_DIR }}
      if: steps.compile.outputs.status == 'success'
      run: |
        echo "检查生成的固件文件..."
        FIRMWARE_DIR="bin/targets" # Base directory
        if [ ! -d "$FIRMWARE_DIR" ] || [ -z "$(ls -A $FIRMWARE_DIR)" ]; then
            echo "错误：固件输出目录 '$FIRMWARE_DIR' 不存在或为空！编译可能未生成任何目标文件。"
            echo "ls -lA bin/:"
            ls -lA bin/ || true
            echo "ls -lA build_dir:"
            ls -lA ${{ env.BUILD_DIR }} | head -n 20 || true # Show top level build_dir contents
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
        fi

        echo "在 '$FIRMWARE_DIR' 中搜索固件文件..."
        # Find files commonly associated with firmware images
        find "$FIRMWARE_DIR" -type f \( \
            -name "*sysupgrade.bin" -o \
            -name "*factory.bin" -o \
            -name "*combined.img" -o \
            -name "*combined.bin" -o \
            -name "*.img.gz" -o \
            -name "*rootfs.squashfs" -o \
            -name "*initramfs-kernel.bin" \
          \) -print -exec ls -lh {} \;

        # Count found files
        FIRMWARE_FILES_COUNT=$(find "$FIRMWARE_DIR" -type f \( -name "*sysupgrade.bin" -o -name "*factory.bin" -o -name "*combined.img" -o -name "*combined.bin" -o -name "*.img.gz" -o -name "*rootfs.squashfs" -o -name "*initramfs-kernel.bin" \) | wc -l)

        if [ "$FIRMWARE_FILES_COUNT" -eq 0 ]; then
            echo "警告：在 '$FIRMWARE_DIR' 中未找到常见的固件文件名格式。"
            echo "列出 '$FIRMWARE_DIR' 下的所有文件以供检查:"
            find "$FIRMWARE_DIR" -type f -exec ls -lh {} \;
            # Decide if this is a failure or just unexpected naming
            # For now, let's allow proceeding but flag it
            echo "将继续，但可能需要手动检查 Artifact。"
            echo "status=warning" >> $GITHUB_OUTPUT
        else
            echo "找到 $FIRMWARE_FILES_COUNT 个可能的固件文件。"
            echo "status=success" >> $GITHUB_OUTPUT
        fi

    # --- 缓存保存 ---
    - name: 保存 Build Essentials 缓存
      uses: actions/cache/save@v4 # Use save action explicitly
      if: "!cancelled()" # Only run if the job wasn't cancelled
      with:
        path: |
          ${{ env.DL_DIR }}
          ${{ env.STAGING_DIR }}
          ${{ env.BUILD_DIR_HOST }}
          ${{ env.BUILD_DIR_TOOLCHAIN }}
          ${{ env.BUILD_DIR_TARGET }} # Attempt to save target intermediates
        key: build-essentials-${{ runner.os }}-${{ env.REPO_BRANCH }} # Must match restore key

    - name: 保存 CCACHE 缓存
      uses: actions/cache/save@v4
      if: "!cancelled()"
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: 保存构建状态缓存
      uses: actions/cache/save@v4
      if: "!cancelled()"
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-${{ runner.os }}-${{ env.REPO_BRANCH }}

    - name: 整理文件用于上传
      id: organize
      # Run if compile succeeded OR if check_firmware gave a warning (meaning files exist but names might be odd)
      if: (steps.compile.outputs.status == 'success' || steps.check_firmware.outputs.status == 'warning') && env.UPLOAD_FIRMWARE == 'true' && !cancelled()
      run: |
        echo "整理固件文件用于上传..."
        ARTIFACT_DIR="${{ env.WORK_DIR }}/openwrt-artifact" # Create a dedicated artifact directory
        FIRMWARE_SRC_DIR="${{ env.OPENWRT_DIR }}/bin/targets"

        rm -rf "$ARTIFACT_DIR" # Clean previous attempt
        mkdir -p "$ARTIFACT_DIR"

        # Find the specific target sub-directory (e.g., x86/64)
        TARGET_SUBDIR=$(find "$FIRMWARE_SRC_DIR" -mindepth 1 -maxdepth 1 -type d | head -n 1)
        if [ -z "$TARGET_SUBDIR" ]; then
          echo "错误：无法在 $FIRMWARE_SRC_DIR 中找到目标子目录！"
          exit 1
        fi
        TARGET_ARCH_DIR=$(find "$TARGET_SUBDIR" -mindepth 1 -maxdepth 1 -type d | head -n 1)
         if [ -z "$TARGET_ARCH_DIR" ]; then
          echo "错误：无法在 $TARGET_SUBDIR 中找到架构子目录！使用 $TARGET_SUBDIR 本身。"
          TARGET_ARCH_DIR=$TARGET_SUBDIR # Fallback
        fi

        echo "将从 $TARGET_ARCH_DIR 复制文件到 $ARTIFACT_DIR"
        # Copy all files from the deepest target directory found
        cp -r "$TARGET_ARCH_DIR"/* "$ARTIFACT_DIR/" || echo "警告：复制文件时出错，可能部分文件丢失。"

        # Also copy the build config for reference
        if [ -f "${{ env.OPENWRT_DIR }}/.config" ]; then
            cp "${{ env.OPENWRT_DIR }}/.config" "$ARTIFACT_DIR/build_config.txt"
        fi
        # Copy the compile log
         if [ -f "${{ env.OPENWRT_DIR }}/logs/"* ]; then # Find the latest log
            LATEST_LOG=$(ls -t "${{ env.OPENWRT_DIR }}/logs/"*.log | head -n 1)
            if [ -n "$LATEST_LOG" ]; then
              cp "$LATEST_LOG" "$ARTIFACT_DIR/compile.log"
            fi
        fi


        # Check if artifact dir is empty
        if [ -z "$(ls -A $ARTIFACT_DIR)" ]; then
            echo "错误：整理后，$ARTIFACT_DIR 仍然为空！没有文件可上传。"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
        else
            echo "文件整理完成，准备上传 $ARTIFACT_DIR"
            echo "ARTIFACT_PATH=${ARTIFACT_DIR}" >> $GITHUB_ENV # Set env var for upload step
            echo "status=success" >> $GITHUB_OUTPUT
        fi

    - name: 上传固件 Artifact
      uses: actions/upload-artifact@v4
      if: steps.organize.outputs.status == 'success' && !cancelled()
      with:
        name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
        path: ${{ env.ARTIFACT_PATH }} # Use the path set in organize step
        retention-days: 7 # Keep artifacts for 7 days

    - name: 生成发布标签和描述
      id: tag
      # Run if organize succeeded and release upload is enabled
      if: steps.organize.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true' && !cancelled()
      run: |
        RELEASE_TAG="build-$(date +%Y%m%d-%H%M%S)"
        echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT

        # Create release notes file
        cat > release_notes.md <<EOF
        ## OpenWrt Firmware Build 自动构建 (${RELEASE_TAG})

        * **构建时间:** $(date +"%Y-%m-%d %H:%M:%S %Z")
        * **源码分支:** ${{ env.REPO_BRANCH }}
        * **配置文件:** ${{ env.CONFIG_FILE }}
        * **设备目标 (提取):** ${{ env.DEVICE_NAME }}

        **包含文件:** (请检查下面的附件)
        * 固件镜像文件 (通常为 `.bin`, `.img`, `.img.gz` 等)
        * `build_config.txt`: 本次构建使用的 OpenWrt `.config` 文件。
        * `compile.log`: 本次构建的主要编译日志。

        **注意:** 刷机前请务必备份您当前设备的配置！此固件按原样提供，不提供任何保证。
        EOF

    - name: 上传固件到 Releases
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success' && !cancelled()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        name: "OpenWrt Auto Build ${{ steps.tag.outputs.RELEASE_TAG }}"
        body_path: release_notes.md
        # Upload all files from the organized artifact directory
        files: ${{ env.ARTIFACT_PATH }}/*
        prerelease: false # Mark as a full release (or true for pre-release)

    - name: 删除旧的 Releases (保留最近3个)
      uses: dev-drprasad/delete-older-releases@v1.0.0 # Pinned to a specific version
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 3
        delete_tags: true # Also delete the git tag associated with the old release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: 清理工作目录 (可选, 节省空间)
      if: always() # Run even if previous steps fail to cleanup
      run: |
        echo "清理工作目录 ${{ env.WORK_DIR }}..."
        # Be careful with rm -rf! Double check the path.
        # Keep the artifact dir if needed for debugging upload failures
        # rm -rf ${{ env.WORK_DIR }}/openwrt
        # rm -rf ${{ env.CCACHE_DIR }}
        # rm -rf ${{ env.BUILD_STATE_DIR }}
        echo "清理完成 (部分或全部，根据需要取消注释)"
