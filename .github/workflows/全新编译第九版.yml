name: 全新编译第九版(修复缓存警告)

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH调试'
        required: false
        default: 'false'
      clean_build:
        description: '完全重新编译'
        required: false
        default: 'false'
      config_file:
        description: '配置文件'
        required: false
        default: '增量缓存优化.config'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE: ${{ github.event.inputs.config_file || '增量缓存优化.config' }}
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai
  WORKDIR: /workdir
  CACHE_ARTIFACTS: true # 设置为true以启用构建物存储而不是缓存

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - name: 检出代码
      uses: actions/checkout@main

    - name: 优化磁盘空间
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 20480
        swap-size-mb: 8192
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir'

    - name: 初始化环境
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo -E apt-get -qq update
        sudo -E apt-get -qq install -y ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
        bzip2 ccache clang cmake cpio curl device-tree-compiler flex gawk gcc-multilib g++-multilib gettext \
        genisoimage git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libfuse-dev libglib2.0-dev \
        libgmp3-dev libltdl-dev libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libpython3-dev \
        libreadline-dev libssl-dev libtool llvm lrzsz msmtp ninja-build p7zip p7zip-full patch pkgconf \
        python3 python3-pyelftools python3-setuptools qemu-utils rsync scons squashfs-tools subversion \
        swig texinfo uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev
        sudo -E apt-get -qq clean
        sudo timedatectl set-timezone "$TZ"
        chmod -R 777 /workdir
        df -h
        
        # 设置日期变量供后续使用
        echo "DATE_TAG=$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

    - name: 计算构建指纹
      id: fingerprint
      run: |
        # 创建配置文件副本（如果不存在则创建默认配置）
        CONFIG_PATH="$GITHUB_WORKSPACE/$CONFIG_FILE"
        if [ ! -f "$CONFIG_PATH" ]; then
          echo "CONFIG_TARGET_x86=y" > "$CONFIG_PATH"
          echo "CONFIG_TARGET_x86_64=y" >> "$CONFIG_PATH"
          echo "CONFIG_TARGET_x86_64_DEVICE_generic=y" >> "$CONFIG_PATH"
          echo "CONFIG_PACKAGE_luci=y" >> "$CONFIG_PATH"
        fi
        
        # 计算配置文件MD5和版本ID
        CONFIG_MD5=$(md5sum "$CONFIG_PATH" | awk '{print $1}')
        CONFIG_MD5_SHORT=${CONFIG_MD5:0:8}
        echo "CONFIG_MD5=$CONFIG_MD5" >> $GITHUB_OUTPUT
        echo "CONFIG_MD5_SHORT=$CONFIG_MD5_SHORT" >> $GITHUB_ENV
        
        # 设置构建ID
        BUILD_ID="${REPO_BRANCH}-${CONFIG_MD5:0:8}-$(date +"%Y%m%d")"
        echo "BUILD_ID=$BUILD_ID" >> $GITHUB_OUTPUT
        echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV

    # 使用artifact下载上一次编译的重要组件
    - name: 下载CCACHE
      uses: dawidd6/action-download-artifact@v2
      if: env.CACHE_ARTIFACTS == 'true' && inputs.clean_build != 'true'
      with:
        name: ccache-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/ccache
        workflow: ${{ github.workflow }}
        workflow_conclusion: success
        if_no_artifact_found: ignore
    
    - name: 下载工具链
      uses: dawidd6/action-download-artifact@v2
      if: env.CACHE_ARTIFACTS == 'true' && inputs.clean_build != 'true'
      with:
        name: toolchain-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/toolchain
        workflow: ${{ github.workflow }}
        workflow_conclusion: success
        if_no_artifact_found: ignore
    
    - name: 下载构建目录
      uses: dawidd6/action-download-artifact@v2
      if: env.CACHE_ARTIFACTS == 'true' && inputs.clean_build != 'true'
      with:
        name: build-dir-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/build_dir
        workflow: ${{ github.workflow }}
        workflow_conclusion: success
        if_no_artifact_found: ignore
    
    - name: 下载下载缓存
      uses: dawidd6/action-download-artifact@v2
      if: env.CACHE_ARTIFACTS == 'true' && inputs.clean_build != 'true'
      with:
        name: dl-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/dl
        workflow: ${{ github.workflow }}
        workflow_conclusion: success
        if_no_artifact_found: ignore

    # 使用传统缓存作为备用
    - name: 恢复CCACHE缓存
      uses: actions/cache@v3
      id: cache-ccache
      if: env.CACHE_ARTIFACTS != 'true' || inputs.clean_build == 'true'
      with:
        path: |
          ${{ env.WORKDIR }}/ccache
        key: ccache-${{ env.REPO_BRANCH }}-${{ steps.fingerprint.outputs.CONFIG_MD5 }}-v9
        restore-keys: |
          ccache-${{ env.REPO_BRANCH }}-

    - name: 检查缓存恢复状态
      run: |
        echo "缓存状态检查："
        
        for dir in ccache toolchain build_dir dl; do
          if [ -d "${{ env.WORKDIR }}/$dir" ] && [ "$(ls -A ${{ env.WORKDIR }}/$dir 2>/dev/null)" ]; then
            SIZE=$(du -sh ${{ env.WORKDIR }}/$dir | cut -f1)
            echo "$dir 目录存在，大小: $SIZE"
            
            # 列出一些关键文件以验证内容
            if [ "$dir" = "toolchain" ]; then
              echo "工具链内容:"
              find ${{ env.WORKDIR }}/$dir -name "gcc" -type f | head -5
            elif [ "$dir" = "ccache" ]; then
              echo "CCACHE内容:"
              ls -la ${{ env.WORKDIR }}/$dir | head -5
            fi
          else
            echo "$dir 目录不存在或为空"
            mkdir -p ${{ env.WORKDIR }}/$dir
          fi
        done

    - name: 克隆源代码
      working-directory: ${{ env.WORKDIR }}
      run: |
        if [ ! -d "openwrt" ]; then
          git clone --depth 1 $REPO_URL -b $REPO_BRANCH openwrt
        fi
        ln -sf ${{ env.WORKDIR }}/openwrt $GITHUB_WORKSPACE/openwrt
        cd openwrt
        
        # 创建并链接工具链目录
        mkdir -p staging_dir
        if [ -d "${{ env.WORKDIR }}/toolchain" ] && [ "$(ls -A ${{ env.WORKDIR }}/toolchain 2>/dev/null)" ]; then
          echo "恢复工具链..."
          rsync -a ${{ env.WORKDIR }}/toolchain/ staging_dir/
        fi
        
        # 创建并链接构建目录
        if [ -d "${{ env.WORKDIR }}/build_dir" ] && [ "$(ls -A ${{ env.WORKDIR }}/build_dir 2>/dev/null)" ]; then
          echo "恢复构建目录..."
          ln -sf ${{ env.WORKDIR }}/build_dir build_dir
        else
          mkdir -p build_dir
        fi
        
        # 创建并链接下载目录
        if [ -d "${{ env.WORKDIR }}/dl" ] && [ "$(ls -A ${{ env.WORKDIR }}/dl 2>/dev/null)" ]; then
          echo "恢复下载目录..."
          ln -sf ${{ env.WORKDIR }}/dl dl
        else
          mkdir -p dl
        fi
        
        # 配置feeds
        curl -L -o feeds.conf.default "$FEEDS_CONF_URL" || echo "使用仓库默认feeds配置"

    - name: 配置编译环境
      run: |
        cd ${{ env.WORKDIR }}/openwrt
        
        # 创建diy脚本
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part1.sh
        echo '# Feeds 已通过 FEEDS_CONF_URL 配置' >> $GITHUB_WORKSPACE/diy-part1.sh
        chmod +x $GITHUB_WORKSPACE/diy-part1.sh
        
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part2.sh
        echo 'sed -i "s/OpenWrt /OpenWrt_AutoBuild /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/diy-part2.sh
        chmod +x $GITHUB_WORKSPACE/diy-part2.sh
        
        # 执行diy脚本
        $GITHUB_WORKSPACE/$DIY_P1_SH
        
        # 更新feeds
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        
        # 应用配置
        cp $GITHUB_WORKSPACE/$CONFIG_FILE ./.config
        $GITHUB_WORKSPACE/$DIY_P2_SH
        
        # 优化编译配置
        echo "CONFIG_CCACHE=y" >> .config
        echo "CONFIG_DEVEL=y" >> .config
        echo "CONFIG_AUTOREMOVE=n" >> .config
        echo "CONFIG_AUTOREBUILD=n" >> .config
        
        # 固件生成配置
        echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
        if grep -q "CONFIG_TARGET_x86=y" .config; then
          echo "CONFIG_GRUB_IMAGES=y" >> .config
          echo "CONFIG_TARGET_IMAGES_GZIP=y" >> .config
        fi
        
        make defconfig

    - name: 配置CCACHE
      run: |
        mkdir -p ${{ env.WORKDIR }}/ccache
        export CCACHE_DIR=${{ env.WORKDIR }}/ccache
        ccache -o cache_dir=$CCACHE_DIR
        ccache -o compression=true
        ccache -o compression_level=6
        ccache -o max_size=5G
        ccache -o hash_dir=false
        ccache -o sloppiness=file_macro,locale,include_file_mtime,include_file_ctime,time_macros,file_stat_matches_ctime
        ccache -z
        echo "CCACHE_DIR=$CCACHE_DIR" >> $GITHUB_ENV
        echo "PATH=/usr/lib/ccache:$PATH" >> $GITHUB_ENV

    - name: 开启SSH调试
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    - name: 智能编译固件
      id: compile
      run: |
        cd ${{ env.WORKDIR }}/openwrt
        
        # 设置环境变量
        export CCACHE_DIR=${{ env.WORKDIR }}/ccache
        export PATH="/usr/lib/ccache:$PATH"
        
        # 检查是否需要完整编译
        NEED_FULL_BUILD=false
        
        # 检查工具链是否完整
        if [ ! -f "staging_dir/host/bin/gcc" ] || [ ! -d "staging_dir/toolchain"* ]; then
          NEED_FULL_BUILD=true
          echo "工具链不完整，需要完整编译"
        fi
        
        if [ "${{ inputs.clean_build }}" = "true" ]; then
          NEED_FULL_BUILD=true
          echo "强制完整编译"
        fi
        
        # 下载依赖
        echo "下载依赖包..."
        make download -j8 || make download -j1 V=s
        
        # 确保dl目录内容保存到缓存
        if [ -d "dl" ] && [ "$(ls -A dl 2>/dev/null)" ]; then
          echo "保存dl目录到缓存..."
          mkdir -p ${{ env.WORKDIR }}/dl_temp
          # 只复制小于2MB的文件以确保不超过限制
          find dl -type f -size -2M -exec cp -p {} ${{ env.WORKDIR }}/dl_temp/ \;
          
          # 显示备份大小
          echo "下载缓存大小: $(du -sh ${{ env.WORKDIR }}/dl_temp | cut -f1)"
          
          # 保存一个示例文件以确保目录不为空
          mkdir -p ${{ env.WORKDIR }}/dl
          touch ${{ env.WORKDIR }}/dl/cache_marker.txt
          echo "此文件用于确保缓存目录不为空" > ${{ env.WORKDIR }}/dl/cache_marker.txt
          
          # 复制文件到缓存目录
          cp -a ${{ env.WORKDIR }}/dl_temp/* ${{ env.WORKDIR }}/dl/ 2>/dev/null || true
          rm -rf ${{ env.WORKDIR }}/dl_temp
        fi
        
        # 编译过程
        if [ "$NEED_FULL_BUILD" = "true" ]; then
          echo "执行完整编译..."
          
          # 编译工具链
          make -j$(nproc) tools/compile || make -j1 tools/compile
          make -j$(nproc) toolchain/compile || make -j1 toolchain/compile
          
          # 备份工具链到缓存目录
          echo "备份工具链..."
          mkdir -p ${{ env.WORKDIR }}/toolchain
          cp -a staging_dir/* ${{ env.WORKDIR }}/toolchain/
          
          # 完整编译
          make -j$(nproc) || make -j1
        else
          echo "执行增量编译..."
          make -j$(nproc) || make -j1
        fi
        
        echo "编译完成，显示CCACHE统计:"
        ccache -s
        
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 检查编译结果
      if: always()
      run: |
        cd ${{ env.WORKDIR }}/openwrt
        echo "查找固件文件..."
        find bin/targets -type f -name "*.bin" -o -name "*combined*" -o -name "*sysupgrade*" | xargs ls -lh || echo "未找到固件文件"
        
        # 显示各目录大小
        echo "目录大小："
        for dir in staging_dir build_dir bin dl; do
          if [ -d "$dir" ]; then
            echo "${dir}: $(du -sh $dir | cut -f1)"
          fi
        done
        
        # 检查CCACHE目录大小
        echo "CCACHE目录大小: $(du -sh ${{ env.WORKDIR }}/ccache | cut -f1)"
        
        # 显示可用空间
        df -h

    # 使用旧版的upload-artifact
    - name: 存储CCACHE
      uses: actions/upload-artifact@main
      if: env.CACHE_ARTIFACTS == 'true' && steps.compile.outputs.status == 'success' && !cancelled()
      with:
        name: ccache-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/ccache
        retention-days: 5

    - name: 备份重要工具链文件
      if: env.CACHE_ARTIFACTS == 'true' && steps.compile.outputs.status == 'success' && !cancelled()
      run: |
        cd ${{ env.WORKDIR }}/openwrt
        
        if [ -d "staging_dir" ]; then
          echo "备份关键工具链文件..."
          
          # 确保工具链缓存目录存在
          mkdir -p ${{ env.WORKDIR }}/toolchain
          
          # 备份关键可执行文件和头文件
          echo "备份主机工具链..."
          if [ -d "staging_dir/host/bin" ]; then
            mkdir -p ${{ env.WORKDIR }}/toolchain/staging_dir/host/bin
            rsync -a staging_dir/host/bin/ ${{ env.WORKDIR }}/toolchain/staging_dir/host/bin/
          fi
          
          # 备份交叉编译工具链
          for dir in staging_dir/toolchain-*; do
            if [ -d "$dir" ]; then
              base_dir=$(basename $dir)
              echo "备份交叉编译工具链: $base_dir"
              mkdir -p ${{ env.WORKDIR }}/toolchain/staging_dir/$base_dir/bin
              rsync -a $dir/bin/ ${{ env.WORKDIR }}/toolchain/staging_dir/$base_dir/bin/ || true
            fi
          done
          
          # 生成一个标记文件，确保目录不为空
          echo "工具链缓存版本: $(date)" > ${{ env.WORKDIR }}/toolchain/version.txt
          
          # 显示备份大小
          echo "工具链备份大小: $(du -sh ${{ env.WORKDIR }}/toolchain | cut -f1)"
        fi

    - name: 存储工具链
      uses: actions/upload-artifact@main
      if: env.CACHE_ARTIFACTS == 'true' && steps.compile.outputs.status == 'success' && !cancelled()
      with:
        name: toolchain-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/toolchain
        retention-days: 5

    - name: 备份关键构建文件
      if: env.CACHE_ARTIFACTS == 'true' && steps.compile.outputs.status == 'success' && !cancelled()
      run: |
        cd ${{ env.WORKDIR }}/openwrt
        
        # 确保构建缓存目录不为空
        mkdir -p ${{ env.WORKDIR }}/build_dir
        echo "构建缓存版本: $(date)" > ${{ env.WORKDIR }}/build_dir/version.txt
        
        if [ -d "build_dir" ]; then
          echo "备份关键构建文件..."
          
          # 备份主机构建标记
          if [ -d "build_dir/host" ]; then
            mkdir -p ${{ env.WORKDIR }}/build_dir/host
            echo "备份主机构建状态..." > ${{ env.WORKDIR }}/build_dir/host/status.txt
            find build_dir/host -name ".built" -o -name ".configured" | \
              xargs tar cf - 2>/dev/null | tar xf - -C ${{ env.WORKDIR }} 2>/dev/null || true
          fi
          
          # 备份工具链构建标记
          for dir in build_dir/toolchain-*; do
            if [ -d "$dir" ]; then
              base_dir=$(basename $dir)
              mkdir -p ${{ env.WORKDIR }}/build_dir/$base_dir
              echo "备份工具链构建状态: $base_dir" > ${{ env.WORKDIR }}/build_dir/$base_dir/status.txt
              find $dir -name ".built" -o -name ".configured" | \
                xargs tar cf - 2>/dev/null | tar xf - -C ${{ env.WORKDIR }} 2>/dev/null || true
            fi
          done
        fi
        
        # 显示备份大小
        echo "构建目录备份大小: $(du -sh ${{ env.WORKDIR }}/build_dir | cut -f1)"

    - name: 存储构建目录
      uses: actions/upload-artifact@main
      if: env.CACHE_ARTIFACTS == 'true' && steps.compile.outputs.status == 'success' && !cancelled()
      with:
        name: build-dir-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/build_dir
        retention-days: 5

    - name: 存储下载缓存
      uses: actions/upload-artifact@main
      if: env.CACHE_ARTIFACTS == 'true' && steps.compile.outputs.status == 'success' && !cancelled()
      with:
        name: dl-${{ env.BUILD_ID }}
        path: ${{ env.WORKDIR }}/dl
        retention-days: 5

    - name: 整理固件文件
      id: organize
      if: steps.compile.outputs.status == 'success' && !cancelled()
      run: |
        cd ${{ env.WORKDIR }}/openwrt/bin/targets/*/*
        rm -rf packages
        echo "FIRMWARE=$PWD" >> $GITHUB_ENV
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 上传固件
      uses: actions/upload-artifact@main
      if: steps.organize.outputs.status == 'success' && !cancelled()
      with:
        name: OpenWrt_firmware_${{ env.CONFIG_MD5_SHORT }}_${{ env.DATE_TAG }}
        path: ${{ env.FIRMWARE }}

    - name: 生成发布标签
      id: tag
      if: steps.organize.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true' && !cancelled()
      run: |
        echo "RELEASE_TAG=$(date +"%Y.%m.%d-%H%M")" >> $GITHUB_OUTPUT
        echo "## OpenWrt固件构建完成 📦" > release.txt
        echo "📅 构建时间: $(date +"%Y-%m-%d %H:%M")" >> release.txt
        echo "⚠️ 请在刷机前先做好备份！" >> release.txt
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 上传固件到Release
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success' && !cancelled()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        body_path: release.txt
        files: ${{ env.FIRMWARE }}/*

    - name: 删除旧的Releases
      uses: dev-drprasad/delete-older-releases@master
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 3
        delete_tags: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
