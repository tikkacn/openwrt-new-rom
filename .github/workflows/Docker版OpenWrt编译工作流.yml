name: Docker版OpenWrt编译第11版

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH调试'
        required: false
        default: 'false'
      clean_build:
        description: '完全重新编译'
        required: false
        default: 'false'
      config_file:
        description: '配置文件'
        required: false
        default: '增量缓存优化.config'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE: ${{ github.event.inputs.config_file || '增量缓存优化.config' }}
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai
  WORKDIR: /workdir

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - name: 检出代码
      uses: actions/checkout@main

    - name: 优化磁盘空间
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 20480
        swap-size-mb: 5120
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir'

    - name: 清理磁盘空间
      run: |
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
        sudo rm -rf /usr/share/swift /usr/local/julia* /opt/hostedtoolcache/CodeQL
        docker image prune -a -f
        docker system prune -af
        sudo apt-get clean
        sudo apt-get autoremove -y
        df -h

    - name: 创建工作目录
      run: |
        sudo mkdir -p ${{ env.WORKDIR }}/openwrt
        sudo mkdir -p ${{ env.WORKDIR }}/cache
        sudo mkdir -p ${{ env.WORKDIR }}/cache/dl
        sudo mkdir -p ${{ env.WORKDIR }}/cache/ccache
        # 确保工作目录有正确的权限
        sudo chmod -R 777 ${{ env.WORKDIR }}
        # 创建缓存文件的软链接以加速二次编译
        [ -d "${{ env.WORKDIR }}/cache/dl" ] && sudo ln -sf ${{ env.WORKDIR }}/cache/dl ${{ env.WORKDIR }}/openwrt/dl

    - name: 准备自定义脚本
      run: |
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part1.sh
        echo '# Feeds已通过FEEDS_CONF_URL配置' >> $GITHUB_WORKSPACE/diy-part1.sh
        chmod +x $GITHUB_WORKSPACE/diy-part1.sh
        
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part2.sh
        echo 'sed -i "s/OpenWrt /OpenWrt_Docker_Build /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/diy-part2.sh
        chmod +x $GITHUB_WORKSPACE/diy-part2.sh
        
        if [ ! -f "$GITHUB_WORKSPACE/$CONFIG_FILE" ]; then
          echo "配置文件不存在，创建默认配置"
          echo "CONFIG_TARGET_x86=y" > $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64_DEVICE_generic=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_PACKAGE_luci=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
        fi

    - name: 创建Docker镜像
      run: |
        cat > ${{ env.WORKDIR }}/Dockerfile << 'EOF'
        FROM ubuntu:22.04
        
        ENV DEBIAN_FRONTEND=noninteractive
        ENV TZ=Asia/Shanghai
        ENV FORCE_UNSAFE_CONFIGURE=1
        
        RUN apt-get update && apt-get install -y \
            build-essential clang flex bison g++ gawk gcc-multilib \
            gettext git libncurses5-dev libssl-dev python3-distutils \
            python3-setuptools rsync unzip zlib1g-dev file wget \
            libelf-dev ccache curl xz-utils vim make \
            && apt-get clean \
            && rm -rf /var/lib/apt/lists/*
        
        VOLUME ["/openwrt", "/cache"]
        ENV PATH="/usr/lib/ccache:$PATH"
        ENV CCACHE_DIR=/cache/ccache
        
        WORKDIR /openwrt
        CMD ["/bin/bash"]
        EOF
        
        cd ${{ env.WORKDIR }}
        docker build -t openwrt-builder .

    - name: 克隆源代码
      run: |
        cd ${{ env.WORKDIR }}
        
        if [ "${{ github.event.inputs.clean_build }}" = "true" ] || [ ! -d "openwrt/.git" ]; then
          echo "克隆OpenWrt源码..."
          rm -rf openwrt
          git clone --depth 1 $REPO_URL -b $REPO_BRANCH openwrt
        else
          echo "更新源码..."
          cd openwrt
          git pull
        fi
        
        cp $GITHUB_WORKSPACE/$CONFIG_FILE ${{ env.WORKDIR }}/openwrt/.config
        cp $GITHUB_WORKSPACE/$DIY_P1_SH ${{ env.WORKDIR }}/openwrt/
        cp $GITHUB_WORKSPACE/$DIY_P2_SH ${{ env.WORKDIR }}/openwrt/

    - name: 编译OpenWrt
      id: compile
      run: |
        cat > ${{ env.WORKDIR }}/compile.sh << 'EOF'
        #!/bin/bash
        
        cd /openwrt
        
        # 更新feeds
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        
        # 添加Go编译修复
        find ./ -name "golang-build.sh" | xargs -I {} sed -i 's/\(go build\)/\1 -buildvcs=false/g' {} || true
        
        # 运行自定义脚本
        chmod +x ./diy-part1.sh
        ./diy-part1.sh
        
        # 二次更新feeds
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        
        # 运行第二个脚本
        chmod +x ./diy-part2.sh
        ./diy-part2.sh
        
        # 配置
        echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
        echo "CONFIG_TARGET_IMAGES_GZIP=y" >> .config
        echo "CONFIG_TARGET_ROOTFS_TARGZ=y" >> .config
        echo "CONFIG_GRUB_IMAGES=y" >> .config
        echo "CONFIG_TARGET_IMAGES_PAD=y" >> .config
        echo "CONFIG_AUTOREMOVE=n" >> .config
        echo "CONFIG_CCACHE=y" >> .config
        
        make defconfig
        
        # Go包修复
        find ./feeds -name "Makefile" -exec grep -l "GO_PKG" {} \; | while read file; do
          if ! grep -q "GO_BUILD_FLAGS" "$file"; then
            sed -i '/GO_PKG/a GO_BUILD_FLAGS:=-buildvcs=false' "$file" || true
          fi
        done
        
        if [ -d "./feeds/packages/net/mosdns" ]; then
          sed -i '/PKG_NAME:=mosdns/a GO_BUILD_FLAGS:=-buildvcs=false' ./feeds/packages/net/mosdns/Makefile || true
        fi
        
        # 创建占位包
        for pkg in tailscale daed daed-geoip daed-geosite nebula nebula-proto; do
          mkdir -p ./feeds/packages/net/$pkg
          cat > ./feeds/packages/net/$pkg/Makefile << EOT
        include \$(TOPDIR)/rules.mk
        PKG_NAME:=$pkg
        PKG_VERSION:=0.0.1
        PKG_RELEASE:=1
        PKG_LICENSE:=MIT
        include \$(INCLUDE_DIR)/package.mk
        define Package/$pkg
          SECTION:=net
          CATEGORY:=Network
          TITLE:=Placeholder for $pkg
        endef
        define Package/$pkg/description
          Placeholder package
        endef
        define Build/Compile
        endef
        define Package/$pkg/install
          \$(INSTALL_DIR) \$(1)/etc
          touch \$(1)/etc/$pkg
        endef
        \$(eval \$(call BuildPackage,$pkg))
        EOT
        done
        
        # 下载所有依赖
        make download -j8 || make download -j1
        
        # 设置CCACHE环境变量优化增量编译
        export CCACHE_DIR=/cache/ccache
        export CCACHE_COMPILERCHECK=content
        export CCACHE_COMPRESS=1
        export CCACHE_MAXSIZE=10G
        
        # 尝试编译，显示编译进度
        echo "开始编译，使用$(nproc)个线程..."
        make -j$(nproc) V=s || make -j1 V=s
        
        # 检查编译结果
        if [ $? -ne 0 ]; then
          echo "编译失败，但继续处理..."
        else
          echo "编译成功!"
        fi
        
        # 确保固件目录存在并设置权限
        mkdir -p bin/targets/x86/64/firmware
        chmod -R 777 bin/targets/x86/64
        
        # 复制固件和其他重要文件
        find bin/targets/x86/64 -name "*.gz" -exec cp -v {} bin/targets/x86/64/firmware/ \; || true
        find bin/targets/x86/64 -name "*.img" -exec cp -v {} bin/targets/x86/64/firmware/ \; || true
        find bin/targets/x86/64 -name "*.vdi" -exec cp -v {} bin/targets/x86/64/firmware/ \; || true
        find bin/targets/x86/64 -name "*.vmdk" -exec cp -v {} bin/targets/x86/64/firmware/ \; || true
        
        # 复制配置和版本信息
        cp .config bin/targets/x86/64/firmware/config.txt || true
        date > bin/targets/x86/64/firmware/build_date.txt
        [ -f ./version.buildinfo ] && cp ./version.buildinfo bin/targets/x86/64/firmware/ || true
        
        # 确保目录不为空
        if [ -z "$(ls -A bin/targets/x86/64/firmware)" ]; then
          echo "编译未生成固件或复制失败，创建占位文件..."
          echo "OpenWrt Build Info" > bin/targets/x86/64/firmware/info.txt
          echo "构建时间: $(date)" >> bin/targets/x86/64/firmware/info.txt
          echo "请检查编译日志以获取详细信息" >> bin/targets/x86/64/firmware/info.txt
        else
          echo "固件文件已成功复制到firmware目录"
          ls -la bin/targets/x86/64/firmware/
        fi
        
        # 设置权限
        chmod -R 777 bin/targets/x86/64/firmware
        EOF
        
        chmod +x ${{ env.WORKDIR }}/compile.sh
        
        docker run --rm \
          -v ${{ env.WORKDIR }}/openwrt:/openwrt \
          -v ${{ env.WORKDIR }}/cache:/cache \
          -v ${{ env.WORKDIR }}/compile.sh:/compile.sh \
          openwrt-builder /compile.sh
        
        # 设置输出
        echo "status=success" >> $GITHUB_OUTPUT
        echo "DEVICE_NAME=_x86_64" >> $GITHUB_ENV
        echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

    - name: SSH调试
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    - name: 整理固件文件
      id: organize
      run: |
        # 不需要再创建目录，使用Docker中已创建的目录
        echo "FIRMWARE=${{ env.WORKDIR }}/openwrt/bin/targets/x86/64/firmware" >> $GITHUB_ENV
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 上传固件
      uses: actions/upload-artifact@main
      if: steps.organize.outputs.status == 'success'
      with:
        name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
        path: ${{ env.FIRMWARE }}

    - name: 生成发布标签
      id: tag
      if: env.UPLOAD_RELEASE == 'true'
      run: |
        echo "RELEASE_TAG=$(date +"%Y.%m.%d-%H%M")" >> $GITHUB_OUTPUT
        echo "## OpenWrt Docker构建固件" > release.txt
        echo "📅 构建时间: $(date +"%Y-%m-%d %H:%M")" >> release.txt
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 上传固件到Releases
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        body_path: release.txt
        files: ${{ env.FIRMWARE }}/*

    - name: 删除旧的Releases
      uses: dev-drprasad/delete-older-releases@master
      if: env.UPLOAD_RELEASE == 'true'
      with:
        keep_latest: 3
        delete_tags: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
