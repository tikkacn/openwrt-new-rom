name: 全新编译Docker缓存优化第11版

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH调试'
        required: false
        default: 'false'
      clean_build:
        description: '完全重新编译'
        required: false
        default: 'false'
      config_file:
        description: '配置文件'
        required: false
        default: '增量缓存优化.config'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE: ${{ github.event.inputs.config_file || '增量缓存优化.config' }}
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai
  # 缓存目录环境变量
  WORKDIR: /workdir
  CACHE_DIR: /workdir/cache
  CCACHE_DIR: /workdir/cache/ccache
  DL_DIR: /workdir/cache/dl
  BUILD_DIR: /workdir/cache/build_dir
  STAGING_DIR: /workdir/cache/staging_dir
  TOOLCHAIN_DIR: /workdir/cache/staging_dir
  BUILD_STATE_DIR: /workdir/cache/build_state
  # 使用更可靠的Docker镜像
  DOCKER_CONTAINER: mwarning/openwrt-builder:latest

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: 检出代码
      uses: actions/checkout@main

    - name: 优化磁盘空间
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 20480
        swap-size-mb: 5120
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir'

    - name: 额外清理磁盘空间并检查
      run: |
        echo "清理额外磁盘空间..."
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost
        sudo rm -rf /usr/share/swift /usr/local/julia* /opt/hostedtoolcache/CodeQL
        docker image prune -a -f || true
        docker system prune -af || true
        sudo apt-get clean
        sudo apt-get autoremove -y
        ROOT_AVAIL=$(df -m /dev/root | tail -1 | awk '{print $4}')
        echo "根分区可用空间: ${ROOT_AVAIL}MB"
        if [ "$ROOT_AVAIL" -lt 20480 ]; then
          echo "错误：/dev/root 可用空间不足 20GB"
          exit 1
        fi
        df -h

    - name: 拉取Docker镜像
      run: |
        echo "拉取Docker构建镜像..."
        # 先尝试拉取镜像，如果失败则安装本地依赖
        if ! docker pull ${{ env.DOCKER_CONTAINER }}; then
          echo "Docker镜像拉取失败，创建本地构建环境..."
          # 创建一个简单的Dockerfile
          cat > Dockerfile << 'EOF'
FROM debian:11

RUN apt-get update && apt-get install -y \
    build-essential \
    ccache \
    clang \
    cmake \
    curl \
    file \
    g++ \
    gawk \
    gcc \
    gettext \
    git \
    libelf-dev \
    libncurses5-dev \
    libssl-dev \
    make \
    msmtp \
    perl \
    python3 \
    python3-pip \
    rsync \
    unzip \
    wget \
    zlib1g-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# 添加一个用户以避免权限问题
RUN useradd -m builder -u 1000 \
    && echo "builder ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/builder \
    && chmod 0440 /etc/sudoers.d/builder

USER builder
WORKDIR /home/builder

ENV PATH="/usr/lib/ccache:${PATH}"
EOF
          docker build -t local/openwrt-builder:latest .
          # 使用本地构建的镜像
          echo "DOCKER_CONTAINER=local/openwrt-builder:latest" >> $GITHUB_ENV
        fi
        
        # 创建缓存目录
        echo "创建缓存目录结构..."
        mkdir -p ${{ env.CACHE_DIR }}/{ccache,dl,build_dir,staging_dir,build_state}
        chmod -R 777 ${{ env.CACHE_DIR }}
        
        # 在工作目录下创建openwrt目录
        mkdir -p ${{ env.WORKDIR }}/openwrt
        chmod -R 777 ${{ env.WORKDIR }}/openwrt
        
        # 显示目录结构和权限
        ls -la ${{ env.WORKDIR }}
        ls -la ${{ env.CACHE_DIR }}

    # 恢复dl目录缓存
    - name: 恢复下载缓存
      uses: actions/cache@v3
      id: cache-dl
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.DL_DIR }}
        key: dl-${{ env.REPO_BRANCH }}-${{ hashFiles('feeds.conf.default') }}
        restore-keys: |
          dl-${{ env.REPO_BRANCH }}-

    # 恢复build_dir缓存
    - name: 恢复构建缓存
      uses: actions/cache@v3
      id: cache-build
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.BUILD_DIR }}
        key: build-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}
        restore-keys: |
          build-${{ env.REPO_BRANCH }}-

    # 恢复staging_dir缓存
    - name: 恢复工具链缓存
      uses: actions/cache@v3
      id: cache-staging
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.STAGING_DIR }}
        key: staging-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}
        restore-keys: |
          staging-${{ env.REPO_BRANCH }}-

    # 恢复CCACHE缓存
    - name: 恢复CCACHE缓存
      uses: actions/cache@v3
      id: cache-ccache
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}
        restore-keys: |
          ccache-${{ env.REPO_BRANCH }}-

    # 恢复构建状态缓存
    - name: 恢复构建状态缓存
      uses: actions/cache@v3
      id: cache-state
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}
        restore-keys: |
          state-${{ env.REPO_BRANCH }}-

    - name: 检查缓存恢复状态
      run: |
        echo "CONFIG_FILE: ${{ env.CONFIG_FILE }}"
        echo "下载缓存恢复状态: ${{ steps.cache-dl.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "构建缓存恢复状态: ${{ steps.cache-build.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "工具链缓存恢复状态: ${{ steps.cache-staging.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "CCACHE缓存恢复状态: ${{ steps.cache-ccache.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "构建状态缓存恢复状态: ${{ steps.cache-state.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        
        # 检查缓存目录大小
        echo "下载目录大小: $(du -sh ${{ env.DL_DIR }} 2>/dev/null || echo '目录不存在或为空')"
        echo "构建目录大小: $(du -sh ${{ env.BUILD_DIR }} 2>/dev/null || echo '目录不存在或为空')"
        echo "工具链目录大小: $(du -sh ${{ env.STAGING_DIR }} 2>/dev/null || echo '目录不存在或为空')"
        echo "CCACHE目录大小: $(du -sh ${{ env.CCACHE_DIR }} 2>/dev/null || echo '目录不存在或为空')"
        
        # 检查可用空间
        df -h

    - name: 准备初始化脚本
      run: |
        # 创建DIY脚本
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part1.sh
        echo '# Feeds 已通过 FEEDS_CONF_URL 配置' >> $GITHUB_WORKSPACE/diy-part1.sh
        chmod +x $GITHUB_WORKSPACE/diy-part1.sh
        
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part2.sh
        echo 'sed -i "s/OpenWrt /OpenWrt_AutoBuild /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/diy-part2.sh
        chmod +x $GITHUB_WORKSPACE/diy-part2.sh
        
        # 检查配置文件是否存在
        if [ ! -f "$GITHUB_WORKSPACE/$CONFIG_FILE" ]; then
          echo "警告：配置文件 $CONFIG_FILE 不存在，创建默认配置文件"
          echo "# 创建默认的最小化配置文件" > $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64_DEVICE_generic=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_PACKAGE_luci=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
        fi
        
        # 创建Docker编译脚本
        cat > $GITHUB_WORKSPACE/docker-compile.sh << 'EOF'
        #!/bin/bash
        set -e

        # 显示环境信息
        echo "运行环境: $(uname -a)"
        echo "当前用户: $(whoami)"
        echo "当前目录: $(pwd)"
        echo "目录内容: $(ls -la)"

        # 设置CCACHE
        export CCACHE_DIR=/home/builder/cache/ccache
        ccache -M 8G
        ccache -o compression=true
        ccache -o compression_level=9
        ccache -o hash_dir=false
        ccache -o sloppiness=file_macro,include_file_ctime,include_file_mtime,time_macros
        
        # 设置编译器环境变量
        export PATH="/usr/lib/ccache:$PATH"
        export CONFIG_AUTOREMOVE=n
        export CONFIG_AUTOREBUILD=n
        export FORCE_UNSAFE_CONFIGURE=1
        
        # 配置DL目录
        echo "配置OpenWrt源代码和下载目录..."
        cd /home/builder/openwrt
        
        if [ ! -f ".config" ]; then
          echo "复制配置文件..."
          cp /config_file .config
        fi
        
        # 链接缓存目录
        echo "链接缓存目录..."
        mkdir -p dl build_dir staging_dir
        
        if [ -d "/home/builder/cache/dl" ]; then
          echo "链接dl目录..."
          rm -rf dl
          ln -sf /home/builder/cache/dl ./dl
        else
          echo "创建dl目录..."
          mkdir -p dl
          ln -sf $(pwd)/dl /home/builder/cache/dl
        fi
        
        if [ -d "/home/builder/cache/build_dir" ]; then
          echo "链接build_dir目录..."
          rm -rf build_dir
          ln -sf /home/builder/cache/build_dir ./build_dir
        else
          echo "创建build_dir目录..."
          mkdir -p build_dir
          ln -sf $(pwd)/build_dir /home/builder/cache/build_dir
        fi
        
        if [ -d "/home/builder/cache/staging_dir" ]; then
          echo "链接staging_dir目录..."
          rm -rf staging_dir
          ln -sf /home/builder/cache/staging_dir ./staging_dir
        else
          echo "创建staging_dir目录..."
          mkdir -p staging_dir
          ln -sf $(pwd)/staging_dir /home/builder/cache/staging_dir
        fi
        
        # 获取缓存状态
        REBUILD_TOOLCHAIN=0
        REBUILD_PACKAGES=0
        CLEAN_BUILD="${1:-false}"
        
        if [ "$CLEAN_BUILD" = "true" ]; then
          REBUILD_TOOLCHAIN=1
          REBUILD_PACKAGES=1
          echo "用户请求完全重新编译"
        fi
        
        # 检查配置文件变化
        mkdir -p /home/builder/cache/build_state
        TOOLCHAIN_CONFIG=$(grep "^CONFIG_TARGET" .config | sort)
        TOOLCHAIN_MD5=$(echo "$TOOLCHAIN_CONFIG" | md5sum | awk '{print $1}')
        PREVIOUS_TOOLCHAIN_MD5=$(cat /home/builder/cache/build_state/toolchain.md5 2>/dev/null || echo "")
        PACKAGE_CONFIG=$(grep "^CONFIG_PACKAGE" .config | sort)
        PACKAGE_MD5=$(echo "$PACKAGE_CONFIG" | md5sum | awk '{print $1}')
        PREVIOUS_PACKAGE_MD5=$(cat /home/builder/cache/build_state/package.md5 2>/dev/null || echo "")
        
        if [ -z "$PREVIOUS_TOOLCHAIN_MD5" ] || [ "$TOOLCHAIN_MD5" != "$PREVIOUS_TOOLCHAIN_MD5" ]; then
          echo "工具链配置变化，需要重建工具链"
          REBUILD_TOOLCHAIN=1
        fi
        
        if [ -z "$PREVIOUS_PACKAGE_MD5" ] || [ "$PACKAGE_MD5" != "$PREVIOUS_PACKAGE_MD5" ]; then
          echo "软件包配置变化，需要重新编译包"
          REBUILD_PACKAGES=1
        fi
        
        echo "更新和安装feeds..."
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        make defconfig
        
        # 下载包含重试
        echo "下载源码包..."
        make download -j8 || make download -j1 V=s
        
        # 编译步骤
        if [ $REBUILD_TOOLCHAIN -eq 1 ]; then
          echo "开始构建工具链 (工具链配置已更改)..."
          make tools/compile -j$(nproc) || make tools/compile V=s
          make toolchain/compile -j$(nproc) || make toolchain/compile V=s
        else
          echo "跳过工具链构建 (使用缓存)"
        fi
        
        if [ $REBUILD_PACKAGES -eq 1 ]; then
          echo "编译软件包 (软件包配置已更改)..."
          make package/compile -j$(nproc) IGNORE_ERRORS=1 || make package/compile V=s IGNORE_ERRORS=1
          make package/index V=s
        else
          echo "跳过软件包编译 (使用缓存)"
        fi
        
        # 无论是否重新编译，都生成固件
        echo "生成固件..."
        make -j$(nproc) || make -j1 V=s
        
        # 保存构建状态
        echo "$TOOLCHAIN_MD5" > /home/builder/cache/build_state/toolchain.md5
        echo "$PACKAGE_MD5" > /home/builder/cache/build_state/package.md5
        echo "构建完成，显示生成的固件文件..."
        find bin/targets -type f -name "*.bin" -o -name "*combined*" -o -name "*sysupgrade*" | xargs ls -lh || echo "未找到固件文件!"
        
        # 显示CCACHE统计
        ccache -s
        EOF
        
        chmod +x $GITHUB_WORKSPACE/docker-compile.sh

    - name: 在Docker容器中克隆源代码
      run: |
        # 在Docker容器中克隆源代码
        docker run --rm \
          -v ${{ env.WORKDIR }}/openwrt:/home/builder/openwrt \
          -v ${{ env.CACHE_DIR }}:/home/builder/cache \
          -w /home/builder/openwrt \
          ${{ env.DOCKER_CONTAINER }} \
          /bin/bash -c "git clone --depth 1 ${{ env.REPO_URL }} -b ${{ env.REPO_BRANCH }} . && \
          curl -L -o feeds.conf.default '${{ env.FEEDS_CONF_URL }}' || echo '警告：无法下载 feeds.conf.default，使用仓库默认配置' && \
          cat feeds.conf.default && \
          rm -rf .git"
        
        # 确保权限正确
        sudo chown -R $(id -u):$(id -g) ${{ env.WORKDIR }}/openwrt
        sudo chown -R $(id -u):$(id -g) ${{ env.CACHE_DIR }}
        
        # 复制配置文件到工作目录
        cp $GITHUB_WORKSPACE/$CONFIG_FILE ${{ env.WORKDIR }}/openwrt/.config
        
        echo "源码克隆完成，显示目录结构:"
        ls -la ${{ env.WORKDIR }}/openwrt

    - name: 开启SSH调试
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    - name: 在Docker容器中编译固件
      id: compile
      run: |
        # 复制编译脚本和配置文件到容器
        cp $GITHUB_WORKSPACE/docker-compile.sh ${{ env.WORKDIR }}/openwrt/
        cp $GITHUB_WORKSPACE/$CONFIG_FILE ${{ env.WORKDIR }}/openwrt/config_file
        
        # 在Docker容器中运行编译
        docker run --rm \
          -v ${{ env.WORKDIR }}/openwrt:/home/builder/openwrt \
          -v ${{ env.CACHE_DIR }}:/home/builder/cache \
          -v $GITHUB_WORKSPACE/docker-compile.sh:/home/builder/openwrt/docker-compile.sh \
          -v $GITHUB_WORKSPACE/$CONFIG_FILE:/config_file \
          -w /home/builder/openwrt \
          -e DEBIAN_FRONTEND=noninteractive \
          -e TZ=${{ env.TZ }} \
          ${{ env.DOCKER_CONTAINER }} \
          /bin/bash -c "chmod +x /home/builder/openwrt/docker-compile.sh && /home/builder/openwrt/docker-compile.sh ${{ github.event.inputs.clean_build }}"
        
        # 生成设备名和日期
        cd ${{ env.WORKDIR }}/openwrt
        echo "DEVICE_NAME=_$(grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' | tr '\n' '_')" >> $GITHUB_ENV
        echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV
        echo "status=success" >> $GITHUB_OUTPUT
        
        # 检查编译结果
        echo "检查固件编译结果:"
        find ${{ env.WORKDIR }}/openwrt/bin/targets -type f -name "*.bin" -o -name "*combined*" -o -name "*sysupgrade*" | xargs ls -lh || echo "未找到固件文件!"

    # 保存dl目录缓存
    - name: 保存下载缓存
      uses: actions/cache@v3
      if: "!cancelled()"
      with:
        path: ${{ env.DL_DIR }}
        key: dl-${{ env.REPO_BRANCH }}-${{ hashFiles('feeds.conf.default') }}

    # 保存build_dir缓存
    - name: 保存构建缓存
      uses: actions/cache@v3
      if: "!cancelled()"
      with:
        path: ${{ env.BUILD_DIR }}
        key: build-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}

    # 保存staging_dir缓存
    - name: 保存工具链缓存
      uses: actions/cache@v3
      if: "!cancelled()"
      with:
        path: ${{ env.STAGING_DIR }}
        key: staging-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}

    # 保存CCACHE缓存
    - name: 保存CCACHE缓存
      uses: actions/cache@v3
      if: "!cancelled()"
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}

    # 保存构建状态缓存
    - name: 保存构建状态缓存
      uses: actions/cache@v3
      if: "!cancelled()"
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-${{ env.REPO_BRANCH }}-${{ hashFiles('**/*.config') }}

    - name: 整理文件
      id: organize
      if: steps.compile.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true' && !cancelled()
      run: |
        # 首先广泛搜索所有可能的固件文件
        echo "搜索所有可能的固件文件..."
        find ${{ env.WORKDIR }}/openwrt/bin -type f -name "*.bin" -o -name "*.img" -o -name "*sysupgrade*" -o -name "*combined*" | \
          xargs -r ls -lh || echo "未找到可能的固件文件"
          
        # 检查是否有目标目录
        if [ ! -d "${{ env.WORKDIR }}/openwrt/bin/targets" ]; then
          echo "错误：编译目标目录不存在，可能编译失败"
          # 即使没有固件文件也不报错，而是创建一个空的固件目录
          mkdir -p ${{ env.WORKDIR }}/openwrt/bin/targets/empty/firmware
          echo "FIRMWARE=${{ env.WORKDIR }}/openwrt/bin/targets/empty/firmware" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # 查找所有目标目录
        TARGET_DIRS=$(find ${{ env.WORKDIR }}/openwrt/bin/targets -mindepth 2 -maxdepth 2 -type d)
        
        if [ -z "$TARGET_DIRS" ]; then
          echo "警告：未找到具体目标目录，创建通用目录"
          mkdir -p ${{ env.WORKDIR }}/openwrt/bin/targets/generic/generic
          TARGET_DIRS="${{ env.WORKDIR }}/openwrt/bin/targets/generic/generic"
        fi
        
        # 对于每个目标目录，尝试查找固件文件
        for TARGET_DIR in $TARGET_DIRS; do
          echo "处理目标目录: $TARGET_DIR"
          cd "$TARGET_DIR"
          
          # 创建固件目录并确保它是空的
          rm -rf firmware
          mkdir -p firmware
          
          # 查找固件文件 - 使用更宽松的匹配规则
          FILES_FOUND=0
          
          # 尝试复制标准固件文件
          for pattern in "*combined*" "*sysupgrade*" "*.img" "*.bin"; do
            echo "尝试复制匹配 $pattern 的文件..."
            if find . -maxdepth 1 -name "$pattern" | grep -q .; then
              find . -maxdepth 1 -name "$pattern" -exec cp -f {} ./firmware/ \;
              FILES_FOUND=1
            fi
          done
          
          # 如果没有找到标准固件文件，尝试复制所有非清单文件
          if [ $FILES_FOUND -eq 0 ]; then
            echo "未找到标准固件文件，尝试复制所有可能的文件..."
            find . -maxdepth 1 -type f -not -name "*.manifest" -not -name "*.txt" -not -name "*.json" \
              -not -name "*.buildinfo" -exec cp -f {} ./firmware/ \;
          fi
          
          # 复制配置文件
          if [ -f "${{ env.WORKDIR }}/openwrt/.config" ]; then
            cp -f ${{ env.WORKDIR }}/openwrt/.config ./firmware/config.txt
          fi
          
          # 检查是否成功复制了任何文件
          if [ -n "$(ls -A firmware)" ]; then
            echo "成功复制固件文件到 $TARGET_DIR/firmware"
            echo "固件内容:"
            ls -lh firmware/
            
            echo "FIRMWARE=$TARGET_DIR/firmware" >> $GITHUB_ENV
            echo "status=success" >> $GITHUB_OUTPUT
            break
          else
            echo "警告: $TARGET_DIR 中未找到可用固件文件"
          fi
        done
        
        # 如果没有找到任何固件文件，使用紧急备用方法
        if [ -z "$FIRMWARE" ]; then
          echo "警告：未能在任何目标目录中找到固件文件，使用紧急备用方法"
          BACKUP_DIR="${{ env.WORKDIR }}/openwrt/bin/targets/generic/backup_firmware"
          mkdir -p "$BACKUP_DIR/firmware"
          
          # 复制所有bin目录下的非包文件
          find ${{ env.WORKDIR }}/openwrt/bin -type f -not -path "*/packages/*" -exec cp -f {} "$BACKUP_DIR/firmware/" \;
          
          # 确保至少有一个配置文件
          if [ -f "${{ env.WORKDIR }}/openwrt/.config" ]; then
            cp -f ${{ env.WORKDIR }}/openwrt/.config "$BACKUP_DIR/firmware/config.txt"
          else
            echo "# 紧急备用配置" > "$BACKUP_DIR/firmware/config.txt"
          fi
          
          echo "FIRMWARE=$BACKUP_DIR/firmware" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT
        fi
        
        # 创建固件压缩包
        if [ -n "$FIRMWARE" ]; then
          cd $(dirname "$FIRMWARE")
          zip -r firmware.zip $(basename "$FIRMWARE")
          echo "FIRMWARE_ZIP=$(dirname "$FIRMWARE")/firmware.zip" >> $GITHUB_ENV
        fi

    # 上传固件
    - name: 上传固件目录
      uses: actions/upload-artifact@main
      if: steps.organize.outputs.status == 'success' && !cancelled()
      with:
        name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
        path: ${{ env.FIRMWARE }}

    - name: 生成发布标签
      id: tag
      if: steps.organize.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true' && !cancelled()
      run: |
        echo "RELEASE_TAG=$(date +"%Y.%m.%d-%H%M")" >> $GITHUB_OUTPUT
        echo "## OpenWrt固件构建完成 📦" > release.txt
        echo "📅 构建时间: $(date +"%Y-%m-%d %H:%M")" >> release.txt
        echo "📂 固件下载" >> release.txt
        echo "⚠️ 请在刷机前先做好备份！" >> release.txt
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 上传固件到Releases
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success' && !cancelled()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        body_path: release.txt
        files: ${{ env.FIRMWARE }}/*

    - name: 删除旧的Releases
      uses: dev-drprasad/delete-older-releases@master
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 3
        delete_tags: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
