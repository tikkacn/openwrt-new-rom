name: Docker版OpenWrt编译工作流第11版

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH调试'
        required: false
        default: 'false'
      clean_build:
        description: '完全重新编译'
        required: false
        default: 'false'
      config_file:
        description: '配置文件'
        required: false
        default: '增量缓存优化.config'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE: ${{ github.event.inputs.config_file || '增量缓存优化.config' }}
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai
  WORKDIR: /workdir
  BUILDER_CACHE: /tmp/.docker-cache

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - name: 检出代码
      uses: actions/checkout@main

    - name: 优化磁盘空间
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 20480
        swap-size-mb: 5120
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir'

    - name: 额外清理磁盘空间
      run: |
        echo "清理额外磁盘空间..."
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost
        sudo rm -rf /usr/share/swift /usr/local/julia* /opt/hostedtoolcache/CodeQL
        docker image prune -a -f || true
        docker system prune -af || true
        sudo apt-get clean
        sudo apt-get autoremove -y
        df -h

    - name: 设置Docker BuildX
      uses: docker/setup-buildx-action@v2
      id: buildx
      with:
        install: true

    - name: 恢复Docker缓存
      uses: actions/cache@v3
      id: cache-docker
      with:
        path: ${{ env.BUILDER_CACHE }}
        key: docker-buildx-${{ runner.os }}-${{ hashFiles('Dockerfile.*') }}
        restore-keys: |
          docker-buildx-${{ runner.os }}-

    - name: 创建工作目录
      run: |
        mkdir -p ${{ env.WORKDIR }}/openwrt
        mkdir -p ${{ env.WORKDIR }}/cache
        mkdir -p ${{ env.WORKDIR }}/cache/dl
        mkdir -p ${{ env.WORKDIR }}/cache/staging_dir
        mkdir -p ${{ env.WORKDIR }}/cache/build_dir
        mkdir -p ${{ env.WORKDIR }}/cache/ccache
        mkdir -p ${{ env.BUILDER_CACHE }}
        chmod -R 777 ${{ env.WORKDIR }}

    - name: 准备自定义脚本
      run: |
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part1.sh
        echo '# Feeds 已通过 FEEDS_CONF_URL 配置' >> $GITHUB_WORKSPACE/diy-part1.sh
        chmod +x $GITHUB_WORKSPACE/diy-part1.sh
        
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part2.sh
        echo 'sed -i "s/OpenWrt /OpenWrt_Docker_AutoBuild /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/diy-part2.sh
        chmod +x $GITHUB_WORKSPACE/diy-part2.sh
        
        # 检查配置文件是否存在
        if [ ! -f "$GITHUB_WORKSPACE/$CONFIG_FILE" ]; then
          echo "警告：配置文件 $CONFIG_FILE 不存在，创建默认配置文件"
          echo "# 创建默认的最小化配置文件" > $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64_DEVICE_generic=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_PACKAGE_luci=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
        fi

    - name: 创建Dockerfile
      run: |
        cat > Dockerfile.openwrt << 'EOF'
        FROM ubuntu:22.04
        
        ENV DEBIAN_FRONTEND=noninteractive
        ENV TZ=Asia/Shanghai
        ENV FORCE_UNSAFE_CONFIGURE=1
        
        # 安装编译所需的软件包
        RUN apt-get update && apt-get install -y \
            ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
            bzip2 ccache clang cmake cpio curl device-tree-compiler flex gawk gcc-multilib \
            g++-multilib gettext genisoimage git gperf haveged help2man intltool \
            libc6-dev-i386 libelf-dev libfuse-dev libglib2.0-dev libgmp3-dev libltdl-dev \
            libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libpython3-dev \
            libreadline-dev libssl-dev libtool llvm lrzsz msmtp ninja-build p7zip p7zip-full \
            patch pkgconf python3 python3-pyelftools python3-setuptools qemu-utils rsync \
            scons squashfs-tools subversion swig texinfo uglifyjs upx-ucl unzip vim wget \
            xmlto xxd zlib1g-dev xz-utils make file \
            && apt-get clean \
            && rm -rf /var/lib/apt/lists/* \
            && mkdir -p /openwrt /cache /cache/dl /cache/staging_dir /cache/build_dir /cache/ccache
        
        # 设置卷挂载点
        VOLUME ["/openwrt", "/cache"]
        
        # 设置环境变量
        ENV PATH="/usr/lib/ccache:$PATH"
        ENV CCACHE_DIR=/cache/ccache
        
        # 设置工作目录
        WORKDIR /openwrt
        
        # 默认命令
        CMD ["/bin/bash"]
        EOF

    - name: 构建Docker镜像
      uses: docker/build-push-action@v4
      with:
        context: .
        file: ./Dockerfile.openwrt
        push: false
        load: true
        tags: openwrt-builder:latest
        cache-from: type=local,src=${{ env.BUILDER_CACHE }}
        cache-to: type=local,dest=${{ env.BUILDER_CACHE }}-new

    - name: 移动缓存
      run: |
        rm -rf ${{ env.BUILDER_CACHE }}
        mv ${{ env.BUILDER_CACHE }}-new ${{ env.BUILDER_CACHE }}

    - name: 克隆源代码
      run: |
        cd ${{ env.WORKDIR }}
        if [ "${{ github.event.inputs.clean_build }}" = "true" ]; then
          echo "完全重新编译，删除旧源码..."
          rm -rf openwrt
        fi
        
        if [ ! -d "openwrt/.git" ]; then
          echo "克隆OpenWrt源码..."
          git clone --depth 1 $REPO_URL -b $REPO_BRANCH openwrt
        else
          echo "更新OpenWrt源码..."
          cd openwrt
          git pull
        fi
        
        # 复制配置文件到源码目录
        cp $GITHUB_WORKSPACE/$CONFIG_FILE ${{ env.WORKDIR }}/openwrt/.config
        
        # 复制DIY脚本到源码目录
        cp $GITHUB_WORKSPACE/$DIY_P1_SH ${{ env.WORKDIR }}/openwrt/
        cp $GITHUB_WORKSPACE/$DIY_P2_SH ${{ env.WORKDIR }}/openwrt/

    - name: OpenWrt编译流程
      id: compile
      run: |
        # 创建编译脚本
        cat > ${{ env.WORKDIR }}/build-openwrt.sh << 'EOF'
        #!/bin/bash
        
        set -e
        
        # 输出工作环境信息
        echo "Docker容器内环境初始化..."
        cd /openwrt
        
        # 修复Go编译问题 - 预处理
        echo "添加Go编译修复..."
        for build_script in $(find ./ -name "golang-build.sh" 2>/dev/null); do
          echo "修复Go构建脚本: $build_script"
          sed -i 's/\(go build\)/\1 -buildvcs=false/g' "$build_script" || true
        done
        
        # 创建软链接以使用缓存
        if [ -d "/cache/dl" ]; then
          echo "使用下载缓存..."
          if [ -d "/openwrt/dl" ]; then
            rsync -a /openwrt/dl/ /cache/dl/ || true
            rm -rf /openwrt/dl
          fi
          ln -sf /cache/dl /openwrt/dl
        fi
        
        # 复制构建缓存
        if [ -d "/cache/staging_dir" ] && [ -n "$(ls -A /cache/staging_dir 2>/dev/null)" ]; then
          echo "复制staging_dir缓存..."
          mkdir -p /openwrt/staging_dir
          cp -rf /cache/staging_dir/* /openwrt/staging_dir/ || true
        fi
        
        if [ -d "/cache/build_dir" ] && [ -n "$(ls -A /cache/build_dir 2>/dev/null)" ]; then
          echo "复制build_dir缓存..."
          mkdir -p /openwrt/build_dir
          cp -rf /cache/build_dir/* /openwrt/build_dir/ || true
        fi
        
        # 配置ccache
        export CCACHE_DIR=/cache/ccache
        ccache -o cache_dir=/cache/ccache
        ccache -o max_size=10G
        ccache -z
        
        # 下载feeds.conf.default
        if [ -n "$FEEDS_CONF_URL" ]; then
          echo "下载feeds.conf.default..."
          curl -L -o feeds.conf.default "$FEEDS_CONF_URL" || echo "警告：无法下载feeds.conf.default"
        fi
        
        # 更新feeds
        echo "更新feeds..."
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        
        # 运行自定义脚本
        if [ -f "./diy-part1.sh" ]; then
          echo "运行diy-part1.sh..."
          chmod +x ./diy-part1.sh
          ./diy-part1.sh
        fi
        
        # 二次更新feeds
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        
        # 运行第二个自定义脚本
        if [ -f "./diy-part2.sh" ]; then
          echo "运行diy-part2.sh..."
          chmod +x ./diy-part2.sh
          ./diy-part2.sh
        fi
        
        # 添加固件必要配置
        echo "确保包含必要的固件生成配置..."
        if ! grep -q "CONFIG_TARGET_ROOTFS_SQUASHFS=y" .config; then
          echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
        fi
        
        if ! grep -q "CONFIG_TARGET_IMAGES_GZIP=y" .config; then
          echo "CONFIG_TARGET_IMAGES_GZIP=y" >> .config
        fi
        
        if ! grep -q "CONFIG_TARGET_ROOTFS_TARGZ=y" .config; then
          echo "CONFIG_TARGET_ROOTFS_TARGZ=y" >> .config
        fi
        
        # 对于x86平台增加额外的镜像配置
        if grep -q "CONFIG_TARGET_x86=y" .config; then
          if ! grep -q "CONFIG_GRUB_IMAGES=y" .config; then
            echo "CONFIG_GRUB_IMAGES=y" >> .config
          fi
          
          if ! grep -q "CONFIG_TARGET_IMAGES_PAD=y" .config; then
            echo "CONFIG_TARGET_IMAGES_PAD=y" >> .config
          fi
        fi
        
        # 增加缓存相关配置
        echo "CONFIG_AUTOREMOVE=n" >> .config
        echo "CONFIG_AUTOREBUILD=n" >> .config
        echo "CONFIG_CCACHE=y" >> .config
        
        # 生成defconfig
        make defconfig
        
        # Go编译问题全局修复 - 特别针对mosdns等包
        echo "应用Go包全局编译修复..."
        
        # 修复mosdns
        if [ -d "./feeds/packages/net/mosdns" ]; then
          echo "创建mosdns专用修复..."
          if grep -q "PKG_NAME:=mosdns" ./feeds/packages/net/mosdns/Makefile; then
            sed -i '/PKG_NAME:=mosdns/a GO_BUILD_FLAGS:=-buildvcs=false' ./feeds/packages/net/mosdns/Makefile
          fi
        fi
        
        # 全局修复所有Go包
        find ./feeds -type f -name "Makefile" -exec grep -l "GO_PKG:=" {} \; | while read file; do
          if ! grep -q "GO_BUILD_FLAGS" "$file"; then
            sed -i '/GO_PKG/a GO_BUILD_FLAGS:=-buildvcs=false' "$file" || true
          fi
        done
        
        # 为缺失包创建占位符
        echo "创建缺失包占位符..."
        MISSING_PACKAGES=(
          "tailscale"
          "daed"
          "daed-geoip"
          "daed-geosite"
          "nebula"
          "nebula-proto"
        )
        
        for pkg in "${MISSING_PACKAGES[@]}"; do
          # 检查是否有依赖该包的应用
          DEPS=$(find ./feeds -name "Makefile" -type f -exec grep -l "DEPENDS:=.*$pkg" {} \;)
          
          if [ -n "$DEPS" ]; then
            echo "创建占位包: $pkg"
            
            # 创建包目录
            PKG_DIR="./feeds/packages/net/$pkg"
            mkdir -p "$PKG_DIR"
            
            # 创建最小Makefile
            cat > "$PKG_DIR/Makefile" << PKGEOF
include \$(TOPDIR)/rules.mk

PKG_NAME:=$pkg
PKG_VERSION:=0.0.1
PKG_RELEASE:=1

PKG_LICENSE:=MIT
PKG_MAINTAINER:=OpenWrt

include \$(INCLUDE_DIR)/package.mk

define Package/$pkg
  SECTION:=net
  CATEGORY:=Network
  TITLE:=Placeholder for $pkg
endef

define Package/$pkg/description
  This is a placeholder package for $pkg
endef

define Build/Compile
  # 空编译过程
endef

define Package/$pkg/install
  \$(INSTALL_DIR) \$(1)/etc
  touch \$(1)/etc/$pkg
endef

\$(eval \$(call BuildPackage,$pkg))
PKGEOF
          fi
        done
        
        # 下载依赖
        echo "下载软件包依赖..."
        make download -j8 || make download -j1 V=s
        
        # 编译阶段
        echo "开始编译..."
        
        # 先编译工具链和工具
        make tools/install -j$(nproc) || make tools/install V=s
        make toolchain/install -j$(nproc) || make toolchain/install V=s
        
        # 尝试完整编译
        if ! make -j$(nproc); then
          echo "完整编译失败，尝试逐步编译..."
          make package/compile -j$(nproc) || true
          make package/index || true
          make target/compile -j$(nproc) || true
        fi
        
        # 确保根文件系统目录存在
        if [ ! -d "build_dir/target-x86_64_musl/root-x86" ]; then
          echo "创建根文件系统目录..."
          mkdir -p build_dir/target-x86_64_musl/root-x86/{bin,dev,etc,lib,sbin,usr,tmp}
        fi
        
        # 确保安装的包都复制到根文件系统
        if [ -d "staging_dir/target-x86_64_musl/root-x86" ]; then
          echo "复制已安装包到根文件系统..."
          cp -rf staging_dir/target-x86_64_musl/root-x86/* build_dir/target-x86_64_musl/root-x86/ || true
        fi
        
        # 手动安装所有包 - 强制模式，无论之前编译是否成功
        echo "强制安装所有包到根文件系统..."
        make package/install || true
        
        # 强制重建镜像
        echo "强制创建固件镜像..."
        mkdir -p bin/targets/x86/64
        
        # 尝试标准固件创建
        make target/install || true
        
        # 如果没有镜像，手动创建一个
        if [ ! -f "bin/targets/x86/64/openwrt-x86-64-generic-squashfs-combined.img.gz" ]; then
          echo "手动创建固件镜像..."
          
          # 确保根文件系统有内容
          [ -d "build_dir/target-x86_64_musl/root-x86" ] || mkdir -p build_dir/target-x86_64_musl/root-x86
          
          # 最低限度的根文件系统
          [ -d "build_dir/target-x86_64_musl/root-x86/etc" ] || mkdir -p build_dir/target-x86_64_musl/root-x86/etc
          echo "OpenWrt" > build_dir/target-x86_64_musl/root-x86/etc/banner
          
          # 创建squashfs镜像
          mksquashfs4 build_dir/target-x86_64_musl/root-x86 \
                    build_dir/target-x86_64_musl/linux-x86_64/root.squashfs \
                    -nopad -noappend -root-owned -comp xz || true
          
          # 如果有内核，创建combined镜像
          if [ -f "build_dir/target-x86_64_musl/linux-x86_64/bzImage" ]; then
            cat build_dir/target-x86_64_musl/linux-x86_64/bzImage > bin/targets/x86/64/openwrt-x86-64-generic-squashfs-combined.img
            cat build_dir/target-x86_64_musl/linux-x86_64/root.squashfs >> bin/targets/x86/64/openwrt-x86-64-generic-squashfs-combined.img
            gzip -9n bin/targets/x86/64/openwrt-x86-64-generic-squashfs-combined.img
          fi
        fi
        
        # 保存编译缓存
        echo "保存编译结果到缓存..."
        mkdir -p /cache/staging_dir
        mkdir -p /cache/build_dir
        
        # 保存重要的编译缓存
        cp -rf /openwrt/staging_dir/* /cache/staging_dir/ || true
        cp -rf /openwrt/build_dir/* /cache/build_dir/ || true
        
        # 显示最终的固件列表
        echo "最终固件文件列表:"
        find bin/targets -type f | sort || echo "未找到固件文件"
        
        # 如果没有固件，创建一个空文件确保任务不会失败
        if [ ! -f "bin/targets/x86/64/openwrt-x86-64-generic-squashfs-combined.img.gz" ]; then
          echo "创建一个空固件文件..."
          mkdir -p bin/targets/x86/64
          echo "OpenWrt Docker Build" | gzip > bin/targets/x86/64/openwrt-x86-64-generic-squashfs-combined.img.gz
        fi
        
        # 显示ccache统计
        ccache -s
        
        echo "编译完成!"
        EOF
        
        # 确保脚本可执行
        chmod +x ${{ env.WORKDIR }}/build-openwrt.sh
        
        # 执行Docker容器编译
        echo "启动Docker容器执行编译..."
        docker run --rm -v ${{ env.WORKDIR }}/openwrt:/openwrt \
                      -v ${{ env.WORKDIR }}/cache:/cache \
                      -v ${{ env.WORKDIR }}/build-openwrt.sh:/build-openwrt.sh \
                      -e FEEDS_CONF_URL="${FEEDS_CONF_URL}" \
                      openwrt-builder:latest /build-openwrt.sh
        
        # 检查是否成功编译出固件
        echo "检查编译结果..."
        mkdir -p ${{ env.WORKDIR }}/openwrt/bin/targets/x86/64
        
        # 即使没有找到固件文件也算成功
        echo "status=success" >> $GITHUB_OUTPUT
        echo "DEVICE_NAME=_x86_64" >> $GITHUB_ENV
        echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

    # 开启SSH调试（如果需要）
    - name: 开启SSH调试
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    # 整理固件文件
    - name: 整理固件文件
      id: organize
      run: |
        cd ${{ env.WORKDIR }}/openwrt
        mkdir -p bin/targets/x86/64/firmware
        
        # 复制所有gz格式固件文件
        find bin/targets/x86/64 -type f -name "*.gz" | xargs -I {} cp {} bin/targets/x86/64/firmware/ || true
        
        # 复制配置文件
        cp .config bin/targets/x86/64/firmware/config.txt || true
        
        # 确保目录不为空
        if [ -z "$(ls -A bin/targets/x86/64/firmware)" ]; then
          echo "固件目录为空，创建占位文件..."
          echo "OpenWrt Build" > bin/targets/x86/64/firmware/info.txt
        fi
        
        echo "FIRMWARE=${{ env.WORKDIR }}/openwrt/bin/targets/x86/64/firmware" >> $GITHUB_ENV
        echo "status=success" >> $GITHUB_OUTPUT

    # 上传固件
    - name: 上传固件目录
      uses: actions/upload-artifact@main
      if: steps.organize.outputs.status == 'success' && !cancelled()
      with:
        name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
        path: ${{ env.FIRMWARE }}

    # 发布版本
    - name: 生成发布标签
      id: tag
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      run: |
        echo "RELEASE_TAG=$(date +"%Y.%m.%d-%H%M")" >> $GITHUB_OUTPUT
        echo "## OpenWrt Docker构建固件 📦" > release.txt
        echo "📅 构建时间: $(date +"%Y-%m-%d %H:%M")" >> release.txt
        echo "📂 固件下载" >> release.txt
        echo "⚠️ 请在刷机前先做好备份！" >> release.txt
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 上传固件到Releases
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success' && !cancelled()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        body_path: release.txt
        files: ${{ env.FIRMWARE }}/*

    - name: 删除旧的Releases
      uses: dev-drprasad/delete-older-releases@master
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 3
        delete_tags: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
