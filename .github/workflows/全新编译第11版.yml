name: "全新编译Docker第11版(优化版)"

on:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH调试'
        required: false
        default: 'false'
      clean_build:
        description: '完全重新编译'
        required: false
        default: 'false'
      config_file:
        description: '配置文件'
        required: false
        default: '增量缓存优化.config'

env:
  REPO_URL: https://github.com/coolsnowwolf/lede
  REPO_BRANCH: master
  FEEDS_CONF_URL: https://github.com/tikkacn/openwrt-new-rom/raw/main/feeds.conf.default
  CONFIG_FILE: ${{ github.event.inputs.config_file || '增量缓存优化.config' }}
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai
  DOCKER_WORK_DIR: /workdir
  TOOLCHAIN_DIR: /workdir/openwrt/staging_dir
  DL_DIR: /workdir/openwrt/dl
  BUILD_STATE_DIR: /workdir/build_state
  STAMP_DIR: /workdir/openwrt/staging_dir/stamps
  CCACHE_DIR: /workdir/ccache

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
    - name: 检出代码
      uses: actions/checkout@main

    - name: 优化磁盘空间
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 20480
        swap-size-mb: 5120
        remove-dotnet: 'true'
        remove-android: 'true'
        remove-haskell: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        build-mount-path: '/workdir'

    - name: 额外清理磁盘空间并检查
      run: |
        echo "清理额外磁盘空间..."
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost
        sudo rm -rf /usr/share/swift /usr/local/julia* /opt/hostedtoolcache/CodeQL
        docker image prune -a -f || true
        docker system prune -af || true
        sudo apt-get clean
        sudo apt-get autoremove -y
        ROOT_AVAIL=$(df -m /dev/root | tail -1 | awk '{print $4}')
        echo "根分区可用空间: ${ROOT_AVAIL}MB"
        if [ "$ROOT_AVAIL" -lt 20480 ]; then
          echo "错误：/dev/root 可用空间不足 20GB"
          exit 1
        fi
        df -h

    - name: 初始化环境
      run: |
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part1.sh
        echo '# Feeds 已通过 FEEDS_CONF_URL 配置' >> $GITHUB_WORKSPACE/diy-part1.sh
        chmod +x $GITHUB_WORKSPACE/diy-part1.sh
        
        echo '#!/bin/bash' > $GITHUB_WORKSPACE/diy-part2.sh
        echo 'sed -i "s/OpenWrt /OpenWrt_AutoBuild /" package/lean/default-settings/files/zzz-default-settings' >> $GITHUB_WORKSPACE/diy-part2.sh
        chmod +x $GITHUB_WORKSPACE/diy-part2.sh
        
        if [ ! -f "$GITHUB_WORKSPACE/$CONFIG_FILE" ]; then
          echo "警告：配置文件 $CONFIG_FILE 不存在，创建默认配置文件"
          echo "# 创建默认的最小化配置文件" > $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_TARGET_x86_64_DEVICE_generic=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
          echo "CONFIG_PACKAGE_luci=y" >> $GITHUB_WORKSPACE/$CONFIG_FILE
        fi
        
        cat > Dockerfile << 'EOF'
FROM ubuntu:22.04
ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y \
    ack \
    antlr3 \
    asciidoc \
    autoconf \
    automake \
    autopoint \
    binutils \
    bison \
    build-essential \
    bzip2 \
    ccache \
    clang \
    cmake \
    cpio \
    curl \
    device-tree-compiler \
    flex \
    gawk \
    gcc-multilib \
    g++-multilib \
    genisoimage \
    gettext \
    git \
    gperf \
    haveged \
    help2man \
    intltool \
    libc6-dev-i386 \
    libelf-dev \
    libfuse-dev \
    libglib2.0-dev \
    libgmp3-dev \
    libltdl-dev \
    libmpc-dev \
    libmpfr-dev \
    libncurses5-dev \
    libncursesw5-dev \
    libpython3-dev \
    libreadline-dev \
    libssl-dev \
    libtool \
    llvm \
    lrzsz \
    msmtp \
    ninja-build \
    p7zip \
    p7zip-full \
    patch \
    pkgconf \
    python3 \
    python3-pyelftools \
    python3-setuptools \
    qemu-utils \
    rsync \
    scons \
    squashfs-tools \
    subversion \
    swig \
    texinfo \
    uglifyjs \
    unzip \
    upx-ucl \
    vim \
    wget \
    xmlto \
    xxd \
    zlib1g-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*
WORKDIR /workdir
EOF
        
        docker build -t openwrt-builder -f Dockerfile .
        
        mkdir -p ${{ env.DOCKER_WORK_DIR }}/openwrt
        mkdir -p ${{ env.BUILD_STATE_DIR }} ${{ env.CCACHE_DIR }}

    - name: 恢复下载缓存
      uses: actions/cache@v3
      id: cache-dl
      with:
        path: ${{ env.DL_DIR }}
        key: dl-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}
        restore-keys: |
          dl-docker-${{ env.REPO_BRANCH }}-

    - name: 恢复CCACHE缓存
      uses: actions/cache@v3
      id: cache-ccache
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}
        restore-keys: |
          ccache-docker-${{ env.REPO_BRANCH }}-

    - name: 恢复主机工具链缓存
      uses: actions/cache@v3
      id: cache-host-tools
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.TOOLCHAIN_DIR }}/host
        key: host-tools-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}
        restore-keys: |
          host-tools-docker-${{ env.REPO_BRANCH }}-

    - name: 恢复编译状态
      uses: actions/cache@v3
      id: cache-stamps
      if: inputs.clean_build != 'true'
      with:
        path: |
          ${{ env.STAMP_DIR }}
          /workdir/openwrt/staging_dir/target-*/stamps
          /workdir/openwrt/.packageinfo
        key: stamps-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}
        restore-keys: |
          stamps-docker-${{ env.REPO_BRANCH }}-

    - name: 恢复构建状态缓存
      uses: actions/cache@v3
      id: cache-state
      if: inputs.clean_build != 'true'
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}
        restore-keys: |
          state-docker-${{ env.REPO_BRANCH }}-

    - name: 克隆源代码并配置
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/src -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c "git clone --depth 1 $REPO_URL -b $REPO_BRANCH /workdir/openwrt && \
          cd /workdir/openwrt && \
          rm -rf .git && \
          mkdir -p ${{ env.TOOLCHAIN_DIR }} ${{ env.DL_DIR }} ${{ env.BUILD_STATE_DIR }} ${{ env.STAMP_DIR }}"
        
        cp $GITHUB_WORKSPACE/$CONFIG_FILE ${{ env.DOCKER_WORK_DIR }}/openwrt/.config
        cp $GITHUB_WORKSPACE/$DIY_P1_SH ${{ env.DOCKER_WORK_DIR }}/
        cp $GITHUB_WORKSPACE/$DIY_P2_SH ${{ env.DOCKER_WORK_DIR }}/
        
        docker run --rm -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c "cd /workdir/openwrt && \
          curl -L -o feeds.conf.default '$FEEDS_CONF_URL' || echo '警告：无法下载feeds配置，使用默认配置'"
        
        echo "检查缓存恢复状态："
        echo "下载目录缓存恢复状态: ${{ steps.cache-dl.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "CCACHE缓存恢复状态: ${{ steps.cache-ccache.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "主机工具链缓存恢复状态: ${{ steps.cache-host-tools.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "编译状态缓存恢复状态: ${{ steps.cache-stamps.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        echo "构建状态缓存恢复状态: ${{ steps.cache-state.outputs.cache-hit == 'true' && '成功' || '未找到缓存' }}"
        
        echo "下载目录大小: $(du -sh ${{ env.DL_DIR }} 2>/dev/null || echo '目录不存在或为空')"
        echo "CCACHE目录大小: $(du -sh ${{ env.CCACHE_DIR }} 2>/dev/null || echo '目录不存在或为空')"
        echo "主机工具链目录大小: $(du -sh ${{ env.TOOLCHAIN_DIR }}/host 2>/dev/null || echo '目录不存在或为空')"
        echo "编译状态目录大小: $(du -sh ${{ env.STAMP_DIR }} 2>/dev/null || echo '目录不存在或为空')"

    - name: 配置编译环境
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/src -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c "cd /workdir/openwrt && \
          bash /workdir/diy-part1.sh && \
          ./scripts/feeds update -a && \
          ./scripts/feeds install -a && \
          bash /workdir/diy-part2.sh && \
          echo 'CONFIG_AUTOREMOVE=n' >> .config && \
          echo 'CONFIG_AUTOREBUILD=n' >> .config && \
          echo 'CONFIG_ALL_KMODS=n' >> .config && \
          if ! grep -q 'CONFIG_TARGET_ROOTFS_SQUASHFS=y' .config; then \
            echo 'CONFIG_TARGET_ROOTFS_SQUASHFS=y' >> .config; \
          fi && \
          if ! grep -q 'CONFIG_TARGET_IMAGES_GZIP=y' .config; then \
            echo 'CONFIG_TARGET_IMAGES_GZIP=y' >> .config; \
          fi && \
          if ! grep -q 'CONFIG_TARGET_ROOTFS_TARGZ=y' .config; then \
            echo 'CONFIG_TARGET_ROOTFS_TARGZ=y' >> .config; \
          fi && \
          if grep -q 'CONFIG_TARGET_x86=y' .config; then \
            if ! grep -q 'CONFIG_GRUB_IMAGES=y' .config; then \
              echo 'CONFIG_GRUB_IMAGES=y' >> .config; \
            fi && \
            if ! grep -q 'CONFIG_TARGET_IMAGES_PAD=y' .config; then \
              echo 'CONFIG_TARGET_IMAGES_PAD=y' >> .config; \
            fi; \
          fi && \
          echo 'CONFIG_DOWNLOAD_DIR=\"${{ env.DL_DIR }}\"' >> .config && \
          mkdir -p ${{ env.CCACHE_DIR }} && \
          echo 'CONFIG_CCACHE=y' >> .config && \
          make defconfig"
        
        docker run --rm -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c "cd /workdir/openwrt && \
          echo '最终配置中的镜像生成选项:' && \
          grep -E 'CONFIG_TARGET_ROOTFS|CONFIG_TARGET_IMAGES|CONFIG_GRUB|CONFIG_ISO|CONFIG_EFI' .config || echo '未找到镜像相关配置'"

    - name: 检查源码变化和配置变化
      id: check-changes
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/src -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c "cd /workdir/openwrt && \
          mkdir -p ${{ env.BUILD_STATE_DIR }} && \
          find feeds -type f -name 'Makefile' -exec sha256sum {} \; | sort | sha256sum > ${{ env.BUILD_STATE_DIR }}/feeds.sha256 && \
          CURRENT_FEEDS_HASH=\$(cat ${{ env.BUILD_STATE_DIR }}/feeds.sha256 | awk '{print \$1}') && \
          PREVIOUS_FEEDS_HASH=\$(cat ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256 2>/dev/null | awk '{print \$1}' || echo '') && \
          echo '当前 feeds 哈希: '\$CURRENT_FEEDS_HASH && \
          echo '之前 feeds 哈希: '\$PREVIOUS_FEEDS_HASH && \
          CURRENT_CONFIG_MD5=\$(md5sum .config | awk '{print \$1}') && \
          PREVIOUS_CONFIG_MD5=\$(cat ${{ env.BUILD_STATE_DIR }}/config.md5 2>/dev/null || echo '') && \
          echo '当前配置文件MD5: '\$CURRENT_CONFIG_MD5 && \
          echo '之前配置文件MD5: '\$PREVIOUS_CONFIG_MD5 && \
          if [ '${{ github.event.inputs.clean_build }}' = 'true' ]; then \
            echo '强制完全重新编译' && \
            echo 'BUILD_MODE=full' > ${{ env.BUILD_STATE_DIR }}/build_mode.env; \
          elif [ '${{ steps.cache-host-tools.outputs.cache-hit }}' != 'true' ]; then \
            echo '未找到主机工具链缓存，需要完全编译' && \
            echo 'BUILD_MODE=full' > ${{ env.BUILD_STATE_DIR }}/build_mode.env; \
          elif [ \"\$CURRENT_FEEDS_HASH\" != \"\$PREVIOUS_FEEDS_HASH\" ]; then \
            echo 'feeds 已变更，需要重新编译' && \
            echo 'BUILD_MODE=packages' > ${{ env.BUILD_STATE_DIR }}/build_mode.env; \
          elif [ \"\$CURRENT_CONFIG_MD5\" != \"\$PREVIOUS_CONFIG_MD5\" ]; then \
            echo '配置已变更，需要重新编译包' && \
            echo 'BUILD_MODE=packages' > ${{ env.BUILD_STATE_DIR }}/build_mode.env; \
          else \
            echo '配置和源码均未变更，执行最小增量编译' && \
            echo 'BUILD_MODE=incremental' > ${{ env.BUILD_STATE_DIR }}/build_mode.env; \
          fi && \
          cp ${{ env.BUILD_STATE_DIR }}/feeds.sha256 ${{ env.BUILD_STATE_DIR }}/previous_feeds.sha256 && \
          echo \"\$CURRENT_CONFIG_MD5\" > ${{ env.BUILD_STATE_DIR }}/config.md5"
        
        if [ -f "${{ env.BUILD_STATE_DIR }}/build_mode.env" ]; then
          BUILD_MODE=$(cat ${{ env.BUILD_STATE_DIR }}/build_mode.env | cut -d '=' -f2)
          echo "BUILD_MODE=$BUILD_MODE" >> $GITHUB_ENV
        else
          echo "BUILD_MODE=full" >> $GITHUB_ENV
          echo "警告：未能读取编译模式，默认使用完全编译"
        fi

    - name: 开启SSH调试
      uses: mxschmitt/action-tmate@v3
      if: github.event.inputs.ssh == 'true'

    - name: 下载软件包
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/src -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c '
          cd /workdir/openwrt
          cat > download_with_retry.sh << "EOF"
#!/bin/bash
set -e
MAX_RETRIES=3
RETRY_WAIT=10
retries=0
until [ $retries -ge $MAX_RETRIES ]
do
  echo "尝试下载，第 $((retries+1)) 次，共 $MAX_RETRIES 次..."
  if make download -j8 2>&1 | tee download_attempt_$retries.log; then
    echo "下载成功!"
    exit 0
  fi
  retries=$((retries+1))
  if [ $retries -lt $MAX_RETRIES ]; then
    echo "下载失败，等待 $RETRY_WAIT 秒后重试..."
    sleep $RETRY_WAIT
  fi
done
echo "达到最大重试次数，保存日志以分析失败的包..."
mkdir -p logs
cp download_attempt_$(($retries-1)).log logs/download_failures.log
exit 1
EOF
          chmod +x download_with_retry.sh
          ./download_with_retry.sh || make download -j1 V=s
          mkdir -p ${{ env.CCACHE_DIR }}
          export CCACHE_DIR=${{ env.CCACHE_DIR }}
          ccache -o max_size=2G
          ccache -z
        '
        
        echo "下载目录大小: $(du -sh ${{ env.DL_DIR }} 2>/dev/null | cut -f1 || echo '目录可能不存在')"

    - name: 智能编译固件
      id: compile
      run: |
        docker run --rm -v $GITHUB_WORKSPACE:/src -v ${{ env.DOCKER_WORK_DIR }}:/workdir \
          -e CCACHE_DIR=${{ env.CCACHE_DIR }} \
          -e PATH="/usr/lib/ccache:$PATH" \
          openwrt-builder bash -c "cd /workdir/openwrt && \
            export BUILD_MODE=${{ env.BUILD_MODE }} && \
            echo \"编译模式: \$BUILD_MODE\" && \
            cleanup_temp_files() { \
              echo \"清理临时文件以释放空间...\"; \
              find /tmp -type f -delete || true; \
              df -h; \
            } && \
            save_cache_info() { \
              echo \"保存缓存状态信息...\"; \
              mkdir -p ${{ env.BUILD_STATE_DIR }}; \
              cp .config ${{ env.BUILD_STATE_DIR }}/config.txt; \
              echo \"\$TOOLCHAIN_CONFIG_MD5\" > ${{ env.BUILD_STATE_DIR }}/toolchain.md5; \
              echo \"\$PACKAGE_CONFIG_MD5\" > ${{ env.BUILD_STATE_DIR }}/package.md5; \
              echo \"保存构建状态完成\"; \
            } && \
            TOOLCHAIN_CONFIG=\$(grep \"^CONFIG_TARGET\" .config | sort) && \
            TOOLCHAIN_CONFIG_MD5=\$(echo \"\$TOOLCHAIN_CONFIG\" | md5sum | awk '{print \$1}') && \
            PREVIOUS_TOOLCHAIN_MD5=\$(cat ${{ env.BUILD_STATE_DIR }}/toolchain.md5 2>/dev/null || echo \"\") && \
            PACKAGE_CONFIG=\$(grep \"^CONFIG_PACKAGE\" .config | sort) && \
            PACKAGE_CONFIG_MD5=\$(echo \"\$PACKAGE_CONFIG\" | md5sum | awk '{print \$1}') && \
            PREVIOUS_PACKAGE_MD5=\$(cat ${{ env.BUILD_STATE_DIR }}/package.md5 2>/dev/null || echo \"\") && \
            case \"\$BUILD_MODE\" in \
              full) \
                echo \"执行完全编译流程...\"; \
                make clean; \
                echo \"编译工具链...\"; \
                make -j\$(nproc) tools/compile V=s || make -j1 V=s tools/compile; \
                make -j\$(nproc) toolchain/compile V=s || make -j1 V=s toolchain/compile; \
                echo \"编译完整固件...\"; \
                if ! make -j\$(nproc) V=s; then \
                  make -j1 V=s; \
                fi; \
                ;; \
              packages) \
                echo \"执行包编译流程...\"; \
                make package/clean V=s || make -j1 V=s package/clean; \
                echo \"编译软件包...\"; \
                if ! make -j\$(nproc) package/compile V=s; then \
                  make -j1 V=s package/compile; \
                fi; \
                echo \"创建包索引...\"; \
                make -j\$(nproc) package/index V=s || make -j1 V=s package/index; \
                echo \"生成固件镜像...\"; \
                make -j\$(nproc) target/install V=s || make -j1 V=s target/install; \
                ;; \
              incremental) \
                echo \"执行真正的增量编译流程...\"; \
                find \$(grep ^CONFIG_PACKAGE .config | grep =y | sed -e 's/CONFIG_PACKAGE_\\([^=]*\\)=y/\\1/' | xargs -n1 -i find package -name {}) -type f -name Makefile | xargs touch; \
                if ! make -j\$(nproc) V=s; then \
                  make -j1 V=s; \
                fi; \
                ;; \
              *) \
                echo \"未知的编译模式，默认执行完全编译...\"; \
                if ! make -j\$(nproc) V=s; then \
                  make -j1 V=s; \
                fi; \
                ;; \
            esac && \
            echo \"确保执行固件生成步骤，无论前面编译是否成功...\" && \
            make -j\$(nproc) target/install V=s || make -j1 V=s target/install && \
            save_cache_info && \
            ccache -s && \
            echo \"检查固件生成结果:\" && \
            find bin/targets -type f -name \"*.bin\" -o -name \"*combined*\" -o -name \"*sysupgrade*\" | xargs ls -lh || echo \"没有找到固件文件！\" && \
            DEVICE_NAME=_\$(grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\\1/' | tr '\\n' '_') && \
            echo \"DEVICE_NAME=\$DEVICE_NAME\" > /workdir/device_name.env && \
            FILE_DATE=_\$(date +\"%Y%m%d%H%M\") && \
            echo \"FILE_DATE=\$FILE_DATE\" > /workdir/file_date.env && \
            echo \"status=success\" > /workdir/compile_status.env"
        
        if [ -f "${{ env.DOCKER_WORK_DIR }}/device_name.env" ]; then
          source ${{ env.DOCKER_WORK_DIR }}/device_name.env
          echo "DEVICE_NAME=$DEVICE_NAME" >> $GITHUB_ENV
        fi
        
        if [ -f "${{ env.DOCKER_WORK_DIR }}/file_date.env" ]; then
          source ${{ env.DOCKER_WORK_DIR }}/file_date.env
          echo "FILE_DATE=$FILE_DATE" >> $GITHUB_ENV
        fi
        
        if [ -f "${{ env.DOCKER_WORK_DIR }}/compile_status.env" ]; then
          source ${{ env.DOCKER_WORK_DIR }}/compile_status.env
          echo "status=$status" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
        fi
        
        df -h

    - name: 保存下载缓存
      uses: actions/cache@v3
      if: "!cancelled() && steps.compile.outputs.status == 'success'"
      with:
        path: ${{ env.DL_DIR }}
        key: dl-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}

    - name: 保存CCACHE缓存
      uses: actions/cache@v3
      if: "!cancelled() && steps.compile.outputs.status == 'success'"
      with:
        path: ${{ env.CCACHE_DIR }}
        key: ccache-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}

    - name: 保存主机工具链缓存
      uses: actions/cache@v3
      if: "!cancelled() && steps.compile.outputs.status == 'success'"
      with:
        path: ${{ env.TOOLCHAIN_DIR }}/host
        key: host-tools-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}

    - name: 保存编译状态
      uses: actions/cache@v3
      if: "!cancelled() && steps.compile.outputs.status == 'success'"
      with:
        path: |
          ${{ env.STAMP_DIR }}
          /workdir/openwrt/staging_dir/target-*/stamps
          /workdir/openwrt/.packageinfo
        key: stamps-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}

    - name: 保存构建状态缓存
      uses: actions/cache@v3
      if: "!cancelled() && steps.compile.outputs.status == 'success'"
      with:
        path: ${{ env.BUILD_STATE_DIR }}
        key: state-docker-${{ env.REPO_BRANCH }}-${{ hashFiles('**/feeds.conf.default') }}

    - name: 整理文件
      id: organize
      if: steps.compile.outputs.status == 'success' && env.UPLOAD_FIRMWARE == 'true' && !cancelled()
      run: |
        echo "搜索所有可能的固件文件..."
        docker run --rm -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c "find /workdir/openwrt/bin -type f -name '*.bin' -o -name '*.img' -o -name '*sysupgrade*' -o -name '*combined*' | xargs -r ls -lh || echo '未找到可能的固件文件'"
        
        if [ ! -d "${{ env.DOCKER_WORK_DIR }}/openwrt/bin/targets" ]; then
          echo "错误：编译目标目录不存在，可能编译失败"
          mkdir -p ${{ env.DOCKER_WORK_DIR }}/openwrt/bin/targets/empty/firmware
          echo "FIRMWARE=${{ env.DOCKER_WORK_DIR }}/openwrt/bin/targets/empty/firmware" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        docker run --rm -v ${{ env.DOCKER_WORK_DIR }}:/workdir openwrt-builder bash -c '
          TARGET_DIRS=$(find /workdir/openwrt/bin/targets -mindepth 2 -maxdepth 2 -type d)
          if [ -z "$TARGET_DIRS" ]; then
            echo "警告：未找到具体目标目录，创建通用目录"
            mkdir -p /workdir/openwrt/bin/targets/generic/generic
            TARGET_DIRS="/workdir/openwrt/bin/targets/generic/generic"
          fi
          for TARGET_DIR in $TARGET_DIRS; do
            echo "处理目标目录: $TARGET_DIR"
            cd "$TARGET_DIR"
            rm -rf firmware
            mkdir -p firmware
            FILES_FOUND=0
            for pattern in "*combined*" "*sysupgrade*" "*.img" "*.bin"; do
              echo "尝试复制匹配 $pattern 的文件..."
              if find . -maxdepth 1 -name "$pattern" | grep -q .; then
                find . -maxdepth 1 -name "$pattern" -exec cp -f {} ./firmware/ \;
                FILES_FOUND=1
              fi
            done
            if [ $FILES_FOUND -eq 0 ]; then
              echo "未找到标准固件文件，尝试复制所有可能的文件..."
              find . -maxdepth 1 -type f -not -name "*.manifest" -not -name "*.txt" -not -name "*.json" \
                -not -name "*.buildinfo" -exec cp -f {} ./firmware/ \;
            fi
            if [ -f "/workdir/openwrt/.config" ]; then
              cp -f /workdir/openwrt/.config ./firmware/config.txt
            fi
            if [ -n "$(ls -A firmware)" ]; then
              echo "成功复制固件文件到 $TARGET_DIR/firmware"
              echo "固件内容:"
              ls -lh firmware/
              echo "FIRMWARE=$TARGET_DIR/firmware" > /workdir/firmware_path.env
              echo "status=success" > /workdir/organize_status.env
              break
            else
              echo "警告: $TARGET_DIR 中未找到可用固件文件"
            fi
          done
          if [ ! -f "/workdir/firmware_path.env" ]; then
            echo "警告：未能在任何目标目录中找到固件文件，使用紧急备用方法"
            BACKUP_DIR="/workdir/openwrt/bin/targets/generic/backup_firmware"
            mkdir -p "$BACKUP_DIR/firmware"
            find /workdir/openwrt/bin -type f -not -path "*/packages/*" -exec cp -f {} "$BACKUP_DIR/firmware/" \;
            if [ -f "/workdir/openwrt/.config" ]; then
              cp -f /workdir/openwrt/.config "$BACKUP_DIR/firmware/config.txt"
            else
              echo "# 紧急备用配置" > "$BACKUP_DIR/firmware/config.txt"
            fi
            echo "FIRMWARE=$BACKUP_DIR/firmware" > /workdir/firmware_path.env
            echo "status=success" > /workdir/organize_status.env
          fi
          if [ -f "/workdir/firmware_path.env" ]; then
            source /workdir/firmware_path.env
            cd $(dirname "$FIRMWARE")
            zip -r firmware.zip $(basename "$FIRMWARE")
            echo "FIRMWARE_ZIP=$(dirname "$FIRMWARE")/firmware.zip" >> /workdir/firmware_path.env
          fi
        '
        
        if [ -f "${{ env.DOCKER_WORK_DIR }}/firmware_path.env" ]; then
          source ${{ env.DOCKER_WORK_DIR }}/firmware_path.env
          echo "FIRMWARE=$FIRMWARE" >> $GITHUB_ENV
          if [ -n "$FIRMWARE_ZIP" ]; then
            echo "FIRMWARE_ZIP=$FIRMWARE_ZIP" >> $GITHUB_ENV
          fi
        fi
        
        if [ -f "${{ env.DOCKER_WORK_DIR }}/organize_status.env" ]; then
          source ${{ env.DOCKER_WORK_DIR }}/organize_status.env
          echo "status=$status" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
        fi

    - name: 上传固件目录
      uses: actions/upload-artifact@main
      if: steps.organize.outputs.status == 'success' && !cancelled()
      with:
        name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
        path: ${{ env.FIRMWARE }}

    - name: 生成发布标签
      id: tag
      if: steps.organize.outputs.status == 'success' && env.UPLOAD_RELEASE == 'true' && !cancelled()
      run: |
        echo "RELEASE_TAG=$(date +"%Y.%m.%d-%H%M")" >> $GITHUB_OUTPUT
        echo "## OpenWrt固件构建完成 📦" > release.txt
        echo "📅 构建时间: $(date +"%Y-%m-%d %H:%M")" >> release.txt
        echo "📂 固件下载" >> release.txt
        echo "⚠️ 请在刷机前先做好备份！" >> release.txt
        echo "status=success" >> $GITHUB_OUTPUT

    - name: 上传固件到Releases
      uses: softprops/action-gh-release@v2
      if: steps.tag.outputs.status == 'success' && !cancelled()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.RELEASE_TAG }}
        body_path: release.txt
        files: ${{ env.FIRMWARE }}/*

    - name: 删除旧的Releases
      uses: dev-drprasad/delete-older-releases@master
      if: env.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 3
        delete_tags: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
